# [Руководство по стилю](https://google.github.io/styleguide/)

# Стили Go кода

Ссылка на оригинальную статью: [https://google.github.io/styleguide/go/decisions](https://google.github.io/styleguide/go/decisions)

[Обзор](https://google.github.io/styleguide/go/index) | [Руководство](https://google.github.io/styleguide/go/guide) | [Решения](https://google.github.io/styleguide/go/decisions) | [Лучшие практики](https://google.github.io/styleguide/go/best-practices)

> Это часть серии документов, описывающих [стиль Go](https://google.github.io/styleguide/go/index) в Google. Этот документ является **[нормативным](https://google.github.io/styleguide/go/index#normative), но не [каноническим](https://google.github.io/styleguide/go/index#canonical)** и подчиняется основному [руководству по стилю](https://google.github.io/styleguide/go/guide). Пожалуйста, см. [обзор](https://google.github.io/styleguide/go/index#about) для получения дополнительной информации.

## О статье

Этот документ содержит решения о стиле, предназначенные для единообразия и стандартизации руководства, объяснений и примеров для консультаций, предоставляемых разработчиками читаемости в Go.

Документ не является **исчерпывающим** и будет развиваться со временем. В случаях, когда [основное руководство по стилю](https://google.github.io/styleguide/go/guide) противоречит рекомендациям, предоставленным здесь, **стилевой руководник имеет приоритет**, и этот документ должен быть обновлен в соответствии с этим.

Пожалуйста, см. [Обзор](https://google.github.io/styleguide/go#about) для полного набора документов о стиле Go.

Следующие разделы были перенесены из решений о стиле в другую часть руководства:

* **Форматирование**: см. [руководство#форматирование](https://google.github.io/styleguide/go/guide#formatting)
* **MixedCaps**: см. [руководство#midxed-caps](https://google.github.io/styleguide/go/guide#mixed-caps)
* **Длина линии**: см. [руководство#длина-линии](https://google.github.io/styleguide/go/guide#line-length)

## Названия
Итак, существует несколько правил по именованию в языке Go. Внимание к разделу о наименованиях в рамках [руководства по стилю](https://google.github.io/styleguide/go/guide#naming) для получения общей информации о выборе подходящих имен. Далее в разделах даются более подробные пояснения по конкретным областям, связанным с именованием.

### Подчеркивания
В целом, имена в Go не должны содержать подчеркивания. Однако есть три исключения к этому правилу:

1. Имена пакетов, которые импортируются только сгенерированным кодом, могут содержать подчеркивания. Для получения дополнительной информации об выборе имен пакетов из нескольких слов, можно обратиться к [разделу о именах пакетов](https://google.github.io/styleguide/go/decisions#package-names).
2. Имена функций Test, Benchmark и Example в файлах *_test.go могут содержать подчеркивания.
3. Низкоуровневые библиотеки, взаимодействующие с операционной системой или cgo, могут повторно использовать идентификаторы, как это делается в пакете [`syscall`](https://pkg.go.dev/syscall#pkg-constants). Однако в большинстве кодовых баз такое использование подчеркиваний будет очень редким.

### Названия пакетов

Мы ожидаем, что имена пакетов в Go будут короткими и содержать только строчные буквы. Имя пакета, состоящее из нескольких слов, должно быть написано в нижнем регистре без пробелов или подчёркиваний. Например, пакет с именем [`tabwriter`](https://pkg.go.dev/text/tabwriter) должен называться именно так, а не `tabWriter`, `TabWriter` или `tab_writer`.

Старайся избегать выбора таких имен пакетов, которые могут быть [вытеснены](https://google.github.io/styleguide/go/best-practices#shadowing) обычно используемыми именами локальных переменных. Например, `usercount` - более подходящее имя пакета, чем `count`, так как `count` является общеиспользуемым именем переменной.

Имена пакетов в Go не должны содержать подчёркивания. Если тебе нужно импортировать пакет, имя которого содержит подчёркивание (обычно это происходит из сгенерированного или стороннего кода), то это имя должно быть переименовано при импорте в имя, подходящее для использования в коде на Go.

Одно исключение из этого правила – имена пакетов, которые импортируются только сгенерированным кодом, могут содержать подчёркивания. Конкретные примеры использования подчёркивания включают:

* Использование суффикса _test для внешнего тестового пакета, например, для интеграционного тестирования.
* Использование суффикса _test для примеров [документации на уровне пакета](https://go.dev/blog/examples).

Не рекомендуется использовать неинформативные имена пакетов, такие как `util`, `utility`, `common`, `helper` и так далее. Более подробно об этом можно прочитать в статье ["utility packages"](https://google.github.io/styleguide/go/best-practices#util-packages) на блоге Go.

Когда импортируемый пакет переименовывается (например, `import foopb "path/to/foo_go_proto"`), локальное имя для пакета должно соответствовать вышеуказанным правилам, так как это локальное имя определяет, как ссылаться на символы в пакете внутри файла. Если один и тот же импорт пакета переименовывается в нескольких файлах, особенно в одном или близлежащих пакетах, следует использовать одно и то же локальное имя для достижения согласованности.

А вот ссылка на замечательную [статью в блоге Go о наименованиях пакетов](https://go.dev/blog/package-names).

### Названия получателей

Имена [переменных-получателей](https://golang.org/ref/spec#Method_declarations) должны быть:

* Короткими (обычно длиной в одну или две буквы)
* Сокращеними для самого типа
* Применяться последовательно к каждому приемнику этого типа

| Длинное название  | Лучше назвать |
| ------------- | ------------- |
| `func (tray Tray)`  | `func (t Tray)`  |
| `func (info *ResearchInfo)`  | `func (ri *ResearchInfo)`  |
| `func (this *ReportWriter)`  | `func (w *ReportWriter)`  |
| `func (self *Scanner)`  | `func (s *Scanner)`  |

### Имена констант

Имена констант должны использовать [MixedCaps](https://google.github.io/styleguide/go/guide#mixed-caps), как и все другие имена в Go. ([Экспортируемые](https://tour.golang.org/basics/3) константы начинаются с заглавной буквы, а неэкспортируемые константы начинаются с маленькой буквы.) Это относится даже тогда, когда это нарушает соглашения в других языках. Имена констант не должны быть производными от их значений, а должны объяснять, что это значение обозначает.

```
// Хорошо:
const MaxPacketSize = 512

const (
    ExecuteBit = 1 << iota
    WriteBit
    ReadBit
)
```
Старайтесь не использовать имена констант без MixedCaps и константы с префиксом `K`.
```
// Плохо:
const MAX_PACKET_SIZE = 512
const kMaxBufferSize = 1024
const KMaxUsersPergroup = 500
```
Давайте именовать константы на основе их роли, а не их значений. Если константа не имеет роли помимо своего значения, то нет необходимости определять ее как константу.
```
// Bad:
const Twelve = 12

const (
    UserNameColumn = "username"
    GroupColumn    = "group"
)
```

### Аббревиатуры

Слова в именах, которые являются инициалами или акронимами (например, `URL` и `NATO`), должны быть написаны с использованием одинакового регистра. `URL` должно появляться как `URL` или `url` (как в `urlPony` или `URLPony`), но никогда не как `Url`. То же самое относится к `ID`, когда это сокращение от "identifier"; используйте `appID` вместо `appId`.

* В именах с несколькими аббревиатурами (например, `XMLAPI`, поскольку она содержит `XML` и `API`), каждая буква в данной аббревиатуре должна быть в одинаковом регистре, но каждый инициал в имени не обязательно должен иметь одинаковый регистр.
* В именах с аббревиатурой, содержащей строчную букву (например, `DDoS`, `iOS`, `gRPC`), аббревиатура должна появляться так же, как в стандартном тексте, за исключением того случая, когда вам нужно изменить первую букву в целях [экспортирования](https://golang.org/ref/spec#Exported_identifiers). В таких случаях вся аббревиатура должна иметь одинаковый регистр (например, `ddos`, `IOS`, `GRPC`).

| Аббревиатура | Доступность | Правильно | Неправильно |
| ------------- | ------------- | ------------- | ------------- |
| XML API | Exported | `XMLAPI` | `XmlApi`, `XMLApi`, `XmlAPI`, `XMLapi` |
| XML API | Unexported | `xmlAPI` | `xmlapi`, `xmlApi` |
| iOS | Exported | `IOS` | `Ios`, `IoS` |
| iOS | Unexported | `iOS` | `ios` |
| gRPC | Exported | `GRPC` | `Grpc` |
| gRPC | Unexported | `gRPC` | `grpc` |
| DDoS | Exported | `DDoS` | `DDOS`, `Ddos` |
| DDoS | Unexported | `ddos` | `dDoS`, `dDOS` |

### Геттеры

Названия функций и методов не должны использовать префикс `Get` или `get`, если базовая концепция не использует слово "get" (например, HTTP GET). Предпочтительнее начинать название прямо с существительного, например, использовать `Counts` вместо `GetCounts`.

Если функция включает выполнение сложных вычислений или вызов удаленного сервера, можно использовать другое слово, например `Compute` (вычисление) или `Fetch` (получение), чтобы ясно указать читателю, что вызов функции может занять время, блокироваться или завершиться неудачей.

### Названия переменных

Общее правило состоит в том, что длина имени должна быть пропорциональна размеру его области видимости и обратно пропорциональна количеству его использования в этой области. Переменная, созданная в глобальной области видимости файла, может требовать нескольких слов, тогда как переменная, ограниченная одним внутренним блоком, может быть как одним словом, так и несколькими символами, для того, чтобы код был чистым и не содержал лишней информации.

Вот грубый ориентир. Эти числовые рекомендации не являются строгими правилами. Применяйте суждение, основанное на контексте, [ясности](https://google.github.io/styleguide/go/guide#clarity) и [краткости](https://google.github.io/styleguide/go/guide#concision).

* Маленькая область - это область, в которой выполняется одна или две небольшие операции, скажем, 1-7 строк.
* Средняя область - это несколько небольших или одна большая операция, скажем, 8-15 строк.
* Большая область - это одна или несколько больших операций, скажем, от 15 до 25 строк.
* Очень большая область - это все, что простирается на несколько страниц (скажем, более 25 строк).

Имя, которое может быть полностью понятным (например, `c` для счетчика) внутри маленькой области, может оказаться недостаточным в большой области и потребовать пояснения, чтобы напомнить читателю его назначение в более поздних частях кода. Область, в которой существует много переменных или переменных, представляющих сходные значения или концепции, может потребовать более длинных имен переменных, чем область предполагает.

Специфичность концепции также может помочь в сохранении краткости имени переменной. Например, если предполагается, что используется только одна база данных, короткое имя переменной, такое как `db`, которое обычно зарезервировано для очень маленьких областей, может оставаться полностью понятным даже при очень большой области. В этом случае, единственное слово `database`, вероятно, будет приемлемо, основываясь на размере области, но не обязательно, поскольку `db` является очень распространенным сокращением для этого слова с немногими альтернативными интерпретациями.

Имя локальной переменной должно отражать то, что она содержит и как она используется в текущем контексте, а не откуда получено значение. Например, часто бывает так, что лучшее имя локальной переменной не совпадает с именем поля в структуре или протокольном буфере.

Резюмируя:

* Однословные имена, такие как `count` или `options`, являются хорошим началом.
* Дополнительные слова можно добавить для устранения неоднозначности схожих имен, например `userCount` и `projectCount`.
* Не сокращайте буквы просто, чтобы сэкономить время. Например, предпочтительнее использовать `Sandbox` вместо `Sbx`, особенно для экспортируемых имен.
* Оставляйте [типы и типо-подобные слова](https://google.github.io/styleguide/go/decisions#repetitive-with-type) в большинстве имен переменных.
  * Для чисел имя `userCount` лучше, чем `numUsers` или `usersInt`.
  * Для среза, имя `users` лучше, чем `userSlice`.
  * При необходимости можно добавить квалификатор типа, если в области видимости есть две версии значения, например, можно хранить входные данные в `ageString`, а использовать `age` для преобразованного значения.
* Пропускайте слова, ясные из [окружающего контекста](https://google.github.io/styleguide/go/decisions#repetitive-in-context). Например, при реализации метода `UserCount`, локальная переменная с именем `userCount`, вероятно, будет избыточной; `count`, `users` или даже `c` так же читаемы.

#### Однобуквенные названия переменных

Однобуквенные идентификаторы переменных могут быть полезными для минимизации [повторений](https://google.github.io/styleguide/go/decisions#repetition), но они также могут делать код более непонятным. Ограничьте их использование случаями, когда полное слово очевидно и когда его повторное использование было бы излишним.

Резюмируя:

* Для [переменной-получателя метода](https://google.github.io/styleguide/go/decisions#receiver-names) предпочтительно использовать однобуквенное или двухбуквенное имя.
* Использование знакомых идентификаторов переменных для общих типов часто полезно:
  * `r` для `io.Reader` или `*http.Request`
  * `w` для `io.Writer` или `http.ResponseWriter`
* Однобуквенные идентификаторы допустимы как целочисленные переменные для циклов, особенно для индексов (например, `i`) и координат (например, `x` и `y`).
* Аббревиатуры могут быть допустимыми идентификаторами циклов, когда область короткая, например, `for _, n := range nodes { ... }`.

### Повторение
Исходный код на Go должен избегать ненужного повторения. Одним из распространенных источников этого являются повторяющиеся имена, которые часто содержат лишние слова или повторяют свой контекст или тип. Сам код также может быть излишне повторяющимся, если один и тот же или похожий код появляется несколько раз в непосредственной близости.

Повторяющиеся имена могут принимать различные формы, включая:

#### Название пакета против названия экспортированного символа
При именовании экспортированных символов имя пакета всегда видимо за пределами вашего пакета, поэтому избыточную информацию между ними следует уменьшать или устранять. Если пакет экспортирует только один тип, и он назван в честь самого пакета, каноническое имя для конструктора - `New`, если он требуется.

> Примеры: Повторяющееся имя -> Лучшее имя
> 
> * widget.NewWidget -> widget.New
> * widget.NewWidgetWithName -> widget.NewWithName
> * db.LoadFromDatabase -> db.Load
> * goatteleportutil.CountGoatsTeleported -> gtutil.CountGoatsTeleported или goatteleport.Count
> * myteampb.MyTeamMethodRequest -> mtpb.MyTeamMethodRequest или myteampb.MethodRequest

#### Имя переменной против типа

Компилятор всегда знает тип переменной, и в большинстве случаев для читателя также ясно, какой тип переменной по тому, как она используется. Необходимо уточнить тип переменной только в случае, если ее значение появляется дважды в одной и той же области видимости.

Повторяющееся имя  Лучшее имя
var numUsers int  var users int
var nameString string  var name string
var primaryProject Project  var primary Project
Если значение появляется в нескольких формах, это можно пояснить либо с помощью дополнительного слова, например raw и parsed, либо с помощью базового представления:

// Хорошо:
limitStr := r.FormValue("limit")
limit, err := strconv.Atoi(limitStr)
// Хорошо:
limitRaw := r.FormValue("limit")
limit, err := strconv.Atoi(limitRaw)

Внешний контекст против локальных имен
Имена, которые включают информацию из окружающего контекста, часто создают дополнительный шум без пользы. Имя пакета, имя метода, имя типа, имя функции, путь импорта и даже имя файла могут предоставлять контекст, который автоматически квалифицирует все имена внутри.

// Плохо:
// В пакете "ads/targeting/revenue/reporting"
type AdsTargetingRevenueReport struct{}

func (p *Project) ProjectName() string
// Хорошо:
// В пакете "ads/targeting/revenue/reporting"
type Report struct{}

func (p *Project) Name() string
// Плохо:
// В пакете "sqldb"
type DBConnection struct{}
// Хорошо:
// В пакете "sqldb"
type Connection struct{}
// Плохо:
// В пакете "ads/targeting"
func Process(in pb.FooProto) Report {
    adsTargetingID := in.GetAdsTargetingID()
}
// Хорошо:
// В пакете "ads/targeting"
func Process(in pb.FooProto) Report {
    id := in.GetAdsTargetingID()
}
Повторение следует оценивать в контексте пользователей символа, а не в изоляции. Например, в следующем коде много имен, которые могут быть приемлемыми в некоторых случаях, но излишние в конкретном контексте:

// Плохо:
func (db *DB) UserCount() (userCount int, err error) {
    var userCountInt64 int64
    if dbLoadError := db.LoadFromDatabase("count(distinct users)", &userCountInt64); dbLoadError != nil {
        return 0, fmt.Errorf("failed to load user count: %s", dbLoadError)
    }
    userCount = int(userCountInt64)
    return userCount, nil
}
Вместо этого информацию о именах, которые явны из контекста или использования, можно часто опускать:

// Хорошо:
func (db *DB) UserCount() (int, error) {
    var count int64
    if err := db.Load("count(distinct users)", &count); err != nil {
        return 0, fmt.Errorf("failed to load user count: %s", err)
    }
    return int(count), nil
}
