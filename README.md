# [Руководство по стилю](https://google.github.io/styleguide/)

# Стили Go кода

Ссылка на оригинальную статью: [https://google.github.io/styleguide/go/decisions](https://google.github.io/styleguide/go/decisions)

[Обзор](https://google.github.io/styleguide/go/index) | [Руководство](https://google.github.io/styleguide/go/guide) | [Решения](https://google.github.io/styleguide/go/decisions) | [Лучшие практики](https://google.github.io/styleguide/go/best-practices)

> Это часть серии документов, описывающих [стиль Go](https://google.github.io/styleguide/go/index) в Google. Этот документ является **[нормативным](https://google.github.io/styleguide/go/index#normative), но не [каноническим](https://google.github.io/styleguide/go/index#canonical)** и подчиняется основному [руководству по стилю](https://google.github.io/styleguide/go/guide). Пожалуйста, см. [обзор](https://google.github.io/styleguide/go/index#about) для получения дополнительной информации.

## О статье

Этот документ содержит решения о стиле, предназначенные для единообразия и стандартизации руководства, объяснений и примеров для консультаций, предоставляемых разработчиками читаемости в Go.

Документ не является **исчерпывающим** и будет развиваться со временем. В случаях, когда [основное руководство по стилю](https://google.github.io/styleguide/go/guide) противоречит рекомендациям, предоставленным здесь, **стилевой руководник имеет приоритет**, и этот документ должен быть обновлен в соответствии с этим.

Пожалуйста, см. [Обзор](https://google.github.io/styleguide/go#about) для полного набора документов о стиле Go.

Следующие разделы были перенесены из решений о стиле в другую часть руководства:

* **Форматирование**: см. [руководство#форматирование](https://google.github.io/styleguide/go/guide#formatting)
* **MixedCaps**: см. [руководство#midxed-caps](https://google.github.io/styleguide/go/guide#mixed-caps)
* **Длина линии**: см. [руководство#длина-линии](https://google.github.io/styleguide/go/guide#line-length)

## Названия
Итак, существует несколько правил по именованию в языке Go. Внимание к разделу о наименованиях в рамках [руководства по стилю](https://google.github.io/styleguide/go/guide#naming) для получения общей информации о выборе подходящих имен. Далее в разделах даются более подробные пояснения по конкретным областям, связанным с именованием.

### Подчеркивания
В целом, имена в Go не должны содержать подчеркивания. Однако есть три исключения к этому правилу:

1. Имена пакетов, которые импортируются только сгенерированным кодом, могут содержать подчеркивания. Для получения дополнительной информации об выборе имен пакетов из нескольких слов, можно обратиться к [разделу о именах пакетов](https://google.github.io/styleguide/go/decisions#package-names).
2. Имена функций Test, Benchmark и Example в файлах *_test.go могут содержать подчеркивания.
3. Низкоуровневые библиотеки, взаимодействующие с операционной системой или cgo, могут повторно использовать идентификаторы, как это делается в пакете [`syscall`](https://pkg.go.dev/syscall#pkg-constants). Однако в большинстве кодовых баз такое использование подчеркиваний будет очень редким.

### Названия пакетов

Мы ожидаем, что имена пакетов в Go будут короткими и содержать только строчные буквы. Имя пакета, состоящее из нескольких слов, должно быть написано в нижнем регистре без пробелов или подчёркиваний. Например, пакет с именем [`tabwriter`](https://pkg.go.dev/text/tabwriter) должен называться именно так, а не `tabWriter`, `TabWriter` или `tab_writer`.

Старайся избегать выбора таких имен пакетов, которые могут быть [вытеснены](https://google.github.io/styleguide/go/best-practices#shadowing) обычно используемыми именами локальных переменных. Например, `usercount` - более подходящее имя пакета, чем `count`, так как `count` является общеиспользуемым именем переменной.

Имена пакетов в Go не должны содержать подчёркивания. Если тебе нужно импортировать пакет, имя которого содержит подчёркивание (обычно это происходит из сгенерированного или стороннего кода), то это имя должно быть переименовано при импорте в имя, подходящее для использования в коде на Go.

Одно исключение из этого правила – имена пакетов, которые импортируются только сгенерированным кодом, могут содержать подчёркивания. Конкретные примеры использования подчёркивания включают:

* Использование суффикса _test для внешнего тестового пакета, например, для интеграционного тестирования.
* Использование суффикса _test для примеров [документации на уровне пакета](https://go.dev/blog/examples).

Не рекомендуется использовать неинформативные имена пакетов, такие как `util`, `utility`, `common`, `helper` и так далее. Более подробно об этом можно прочитать в статье ["utility packages"](https://google.github.io/styleguide/go/best-practices#util-packages) на блоге Go.

Когда импортируемый пакет переименовывается (например, `import foopb "path/to/foo_go_proto"`), локальное имя для пакета должно соответствовать вышеуказанным правилам, так как это локальное имя определяет, как ссылаться на символы в пакете внутри файла. Если один и тот же импорт пакета переименовывается в нескольких файлах, особенно в одном или близлежащих пакетах, следует использовать одно и то же локальное имя для достижения согласованности.

А вот ссылка на замечательную [статью в блоге Go о наименованиях пакетов](https://go.dev/blog/package-names).

### Названия получателей

Имена [переменных-получателей](https://golang.org/ref/spec#Method_declarations) должны быть:

* Короткими (обычно длиной в одну или две буквы)
* Сокращеними для самого типа
* Применяться последовательно к каждому приемнику этого типа

| Длинное название  | Лучше назвать |
| ------------- | ------------- |
| `func (tray Tray)`  | `func (t Tray)`  |
| `func (info *ResearchInfo)`  | `func (ri *ResearchInfo)`  |
| `func (this *ReportWriter)`  | `func (w *ReportWriter)`  |
| `func (self *Scanner)`  | `func (s *Scanner)`  |

### Имена констант

Имена констант должны использовать [MixedCaps](https://google.github.io/styleguide/go/guide#mixed-caps), как и все другие имена в Go. ([Экспортируемые](https://tour.golang.org/basics/3) константы начинаются с заглавной буквы, а неэкспортируемые константы начинаются с маленькой буквы.) Это относится даже тогда, когда это нарушает соглашения в других языках. Имена констант не должны быть производными от их значений, а должны объяснять, что это значение обозначает.

```
// Хорошо:
const MaxPacketSize = 512

const (
    ExecuteBit = 1 << iota
    WriteBit
    ReadBit
)
```
Старайтесь не использовать имена констант без MixedCaps и константы с префиксом `K`.
```
// Плохо:
const MAX_PACKET_SIZE = 512
const kMaxBufferSize = 1024
const KMaxUsersPergroup = 500
```
Давайте именовать константы на основе их роли, а не их значений. Если константа не имеет роли помимо своего значения, то нет необходимости определять ее как константу.
```
// Bad:
const Twelve = 12

const (
    UserNameColumn = "username"
    GroupColumn    = "group"
)
```

### Аббревиатуры

Слова в именах, которые являются инициалами или акронимами (например, `URL` и `NATO`), должны быть написаны с использованием одинакового регистра. `URL` должно появляться как `URL` или `url` (как в `urlPony` или `URLPony`), но никогда не как `Url`. То же самое относится к `ID`, когда это сокращение от "identifier"; используйте `appID` вместо `appId`.

* В именах с несколькими аббревиатурами (например, `XMLAPI`, поскольку она содержит `XML` и `API`), каждая буква в данной аббревиатуре должна быть в одинаковом регистре, но каждый инициал в имени не обязательно должен иметь одинаковый регистр.
* В именах с аббревиатурой, содержащей строчную букву (например, `DDoS`, `iOS`, `gRPC`), аббревиатура должна появляться так же, как в стандартном тексте, за исключением того случая, когда вам нужно изменить первую букву в целях [экспортирования](https://golang.org/ref/spec#Exported_identifiers). В таких случаях вся аббревиатура должна иметь одинаковый регистр (например, `ddos`, `IOS`, `GRPC`).

| Аббревиатура | Доступность | Правильно | Неправильно |
| ------------- | ------------- | ------------- | ------------- |
| XML API | Exported | `XMLAPI` | `XmlApi`, `XMLApi`, `XmlAPI`, `XMLapi` |
| XML API | Unexported | `xmlAPI` | `xmlapi`, `xmlApi` |
| iOS | Exported | `IOS` | `Ios`, `IoS` |
| iOS | Unexported | `iOS` | `ios` |
| gRPC | Exported | `GRPC` | `Grpc` |
| gRPC | Unexported | `gRPC` | `grpc` |
| DDoS | Exported | `DDoS` | `DDOS`, `Ddos` |
| DDoS | Unexported | `ddos` | `dDoS`, `dDOS` |

### Геттеры

Названия функций и методов не должны использовать префикс `Get` или `get`, если базовая концепция не использует слово "get" (например, HTTP GET). Предпочтительнее начинать название прямо с существительного, например, использовать `Counts` вместо `GetCounts`.

Если функция включает выполнение сложных вычислений или вызов удаленного сервера, можно использовать другое слово, например `Compute` (вычисление) или `Fetch` (получение), чтобы ясно указать читателю, что вызов функции может занять время, блокироваться или завершиться неудачей.

### Названия переменных

Общее правило состоит в том, что длина имени должна быть пропорциональна размеру его области видимости и обратно пропорциональна количеству его использования в этой области. Переменная, созданная в глобальной области видимости файла, может требовать нескольких слов, тогда как переменная, ограниченная одним внутренним блоком, может быть как одним словом, так и несколькими символами, для того, чтобы код был чистым и не содержал лишней информации.

Вот грубый ориентир. Эти числовые рекомендации не являются строгими правилами. Применяйте суждение, основанное на контексте, [ясности](https://google.github.io/styleguide/go/guide#clarity) и [краткости](https://google.github.io/styleguide/go/guide#concision).

* Маленькая область - это область, в которой выполняется одна или две небольшие операции, скажем, 1-7 строк.
* Средняя область - это несколько небольших или одна большая операция, скажем, 8-15 строк.
* Большая область - это одна или несколько больших операций, скажем, от 15 до 25 строк.
* Очень большая область - это все, что простирается на несколько страниц (скажем, более 25 строк).

Имя, которое может быть полностью понятным (например, `c` для счетчика) внутри маленькой области, может оказаться недостаточным в большой области и потребовать пояснения, чтобы напомнить читателю его назначение в более поздних частях кода. Область, в которой существует много переменных или переменных, представляющих сходные значения или концепции, может потребовать более длинных имен переменных, чем область предполагает.

Специфичность концепции также может помочь в сохранении краткости имени переменной. Например, если предполагается, что используется только одна база данных, короткое имя переменной, такое как `db`, которое обычно зарезервировано для очень маленьких областей, может оставаться полностью понятным даже при очень большой области. В этом случае, единственное слово `database`, вероятно, будет приемлемо, основываясь на размере области, но не обязательно, поскольку `db` является очень распространенным сокращением для этого слова с немногими альтернативными интерпретациями.

Имя локальной переменной должно отражать то, что она содержит и как она используется в текущем контексте, а не откуда получено значение. Например, часто бывает так, что лучшее имя локальной переменной не совпадает с именем поля в структуре или протокольном буфере.

Резюмируя:

* Однословные имена, такие как `count` или `options`, являются хорошим началом.
* Дополнительные слова можно добавить для устранения неоднозначности схожих имен, например `userCount` и `projectCount`.
* Не сокращайте буквы просто, чтобы сэкономить время. Например, предпочтительнее использовать `Sandbox` вместо `Sbx`, особенно для экспортируемых имен.
* Оставляйте [типы и типо-подобные слова](https://google.github.io/styleguide/go/decisions#repetitive-with-type) в большинстве имен переменных.
  * Для чисел имя `userCount` лучше, чем `numUsers` или `usersInt`.
  * Для среза, имя `users` лучше, чем `userSlice`.
  * При необходимости можно добавить квалификатор типа, если в области видимости есть две версии значения, например, можно хранить входные данные в `ageString`, а использовать `age` для преобразованного значения.
* Пропускайте слова, ясные из [окружающего контекста](https://google.github.io/styleguide/go/decisions#repetitive-in-context). Например, при реализации метода `UserCount`, локальная переменная с именем `userCount`, вероятно, будет избыточной; `count`, `users` или даже `c` так же читаемы.

#### Однобуквенные названия переменных

Однобуквенные идентификаторы переменных могут быть полезными для минимизации [повторений](https://google.github.io/styleguide/go/decisions#repetition), но они также могут делать код более непонятным. Ограничьте их использование случаями, когда полное слово очевидно и когда его повторное использование было бы излишним.

Резюмируя:

* Для [переменной-получателя метода](https://google.github.io/styleguide/go/decisions#receiver-names) предпочтительно использовать однобуквенное или двухбуквенное имя.
* Использование знакомых идентификаторов переменных для общих типов часто полезно:
  * `r` для `io.Reader` или `*http.Request`
  * `w` для `io.Writer` или `http.ResponseWriter`
* Однобуквенные идентификаторы допустимы как целочисленные переменные для циклов, особенно для индексов (например, `i`) и координат (например, `x` и `y`).
* Аббревиатуры могут быть допустимыми идентификаторами циклов, когда область короткая, например, `for _, n := range nodes { ... }`.

### Повторение
Исходный код на Go должен избегать ненужного повторения. Одним из распространенных источников этого являются повторяющиеся имена, которые часто содержат лишние слова или повторяют свой контекст или тип. Сам код также может быть излишне повторяющимся, если один и тот же или похожий код появляется несколько раз в непосредственной близости.

Повторяющиеся имена могут принимать различные формы, включая:

#### Название пакета против названия экспортированного символа
При именовании экспортированных символов имя пакета всегда видимо за пределами вашего пакета, поэтому избыточную информацию между ними следует уменьшать или устранять. Если пакет экспортирует только один тип, и он назван в честь самого пакета, каноническое имя для конструктора - `New`, если он требуется.

> Примеры: Повторяющееся имя -> Лучшее имя
> 
> * widget.NewWidget -> widget.New
> * widget.NewWidgetWithName -> widget.NewWithName
> * db.LoadFromDatabase -> db.Load
> * goatteleportutil.CountGoatsTeleported -> gtutil.CountGoatsTeleported или goatteleport.Count
> * myteampb.MyTeamMethodRequest -> mtpb.MyTeamMethodRequest или myteampb.MethodRequest

#### Название переменной против типа

Компилятор всегда знает тип переменной, и в большинстве случаев для читателя также ясно, какой тип переменной по тому, как она используется. Необходимо уточнить тип переменной только в случае, если ее значение появляется дважды в одной и той же области видимости.

| Повторяющееся имя | Лучшее имя |
| ------------- | ------------- |
| `var numUsers int` |  `var users int` |
| `var nameString string` | `var name string` |
| `var primaryProject Project` | `var primary Project` |

Если значение появляется в нескольких формах, это можно пояснить либо с помощью дополнительного слова, например `raw` и `parsed`, либо с помощью базового представления:
```
// Хорошо:
limitStr := r.FormValue("limit")
limit, err := strconv.Atoi(limitStr)
```
```
// Хорошо:
limitRaw := r.FormValue("limit")
limit, err := strconv.Atoi(limitRaw)
```

#### Внешний контекст против локальных названий
Имена, которые включают информацию из окружающего контекста, часто создают дополнительный шум без пользы. Имя пакета, имя метода, имя типа, имя функции, путь импорта и даже имя файла могут предоставлять контекст, который автоматически квалифицирует все имена внутри.
```
// Плохо:
// В пакете "ads/targeting/revenue/reporting"
type AdsTargetingRevenueReport struct{}

func (p *Project) ProjectName() string
```
```
// Хорошо:
// В пакете "ads/targeting/revenue/reporting"
type Report struct{}

func (p *Project) Name() string
```
```
// Плохо:
// В пакете "sqldb"
type DBConnection struct{}
// Хорошо:
// В пакете "sqldb"
type Connection struct{}
```
```
// Плохо:
// В пакете "ads/targeting"
func Process(in pb.FooProto) Report {
    adsTargetingID := in.GetAdsTargetingID()
}
```
```
// Хорошо:
// В пакете "ads/targeting"
func Process(in pb.FooProto) Report {
    id := in.GetAdsTargetingID()
}
```
Повторение следует оценивать в контексте пользователей символа, а не в изоляции. Например, в следующем коде много имен, которые могут быть приемлемыми в некоторых случаях, но излишние в конкретном контексте:
```
// Плохо:
func (db *DB) UserCount() (userCount int, err error) {
    var userCountInt64 int64
    if dbLoadError := db.LoadFromDatabase("count(distinct users)", &userCountInt64); dbLoadError != nil {
        return 0, fmt.Errorf("failed to load user count: %s", dbLoadError)
    }
    userCount = int(userCountInt64)
    return userCount, nil
}
```
Вместо этого информацию о именах, которые явны из контекста или использования, можно часто опускать:
```
// Хорошо:
func (db *DB) UserCount() (int, error) {
    var count int64
    if err := db.Load("count(distinct users)", &count); err != nil {
        return 0, fmt.Errorf("failed to load user count: %s", err)
    }
    return int(count), nil
}
```

## Комментарии
Соглашения относительно комментирования (какие части кода комментировать, какой стиль использовать, как предоставлять запускаемые примеры и т. д.) предназначены для поддержки опыта чтения документации общедоступного API. Смотрите [Effective Go](http://golang.org/doc/effective_go.html#commentary) для получения дополнительной информации.

Лучшие практики документирования обсуждаются более подробно в главе [Правила документирования](https://google.github.io/styleguide/go/best-practices#documentation-conventions)

**Лучшая практика:** используйте [предварительный просмотр документации](https://google.github.io/styleguide/go/best-practices#documentation-preview) во время разработки и обзора кода, чтобы увидеть, полезны ли документация и запускаемые примеры, и представлены ли они так, как вы ожидаете.

**Совет:** Godoc использует очень незначительное форматирование; списки и фрагменты кода обычно следует делать с отступом, чтобы избежать переноса строк. За исключением отступов, обычно следует избегать оформления.

### Длина строки комментария
Обеспечьте возможность чтения комментариев из исходного кода даже на узких экранах.

Когда комментарий становится слишком длинным, рекомендуется разделить его на несколько однострочных комментариев. Старайтесь, по возможности, делать комментарии так, чтобы они хорошо читались на терминале шириной 80 символов, но это не жесткий предел; в Go нет фиксированного ограничения на длину строк комментариев. Например, стандартная библиотека часто разбивает комментарии на отдельные строки в зависимости от знаков препинания, что иногда приводит к длине строк около 60-70 символов.

Существует много существующего кода, в котором комментарии превышают 80 символов в длину. Однако этот факт не должен служить оправданием для изменения такого кода при анализе читаемости (см. [согласованность](https://google.github.io/styleguide/go/guide#consistency), хотя командам рекомендуется при возможности обновлять комментарии в соответствии с этим руководством в рамках других рефакторингов. Основная цель этого руководства - обеспечить, чтобы все руководители читабельности кода на Go давали одни и те же рекомендации при необходимости.

Пример хорошего комментария, который демонстрирует правильное форматирование:
```
// Это параграф комментария.
// Длина отдельных строк не имеет значения в Godoc;
// но выбор разделения делает его легко читаемым на узких экранах.
//
// Не беспокойтесь слишком сильно о длинном URL:
// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/
//
// Аналогично, если у вас есть другая информация, которая становится неудобной
// из-за слишком многих переносов строк, используйте свой суд и включите длинную строку,
// если это помогает, а не мешает.
```
Пример плохого комментария, который не следует рекомендациям форматирования:
```
// Это параграф комментария. Длина отдельных строк не имеет значения в
Godoc;
// но выбор разделения вызывает неровные строки на узких экранах или в рецензии
кода,
// что может быть раздражающим, особенно когда комментарий переносится
постоянно.
//
// Не беспокойтесь слишком сильно о длинном URL:
// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/
```

Важно следовать этим рекомендациям, чтобы сделать ваш код более читабельным и согласованным. Если вам интересно узнать больше о комментировании, рекомендуется прочитать [публикацию в блоге Go о документации](https://blog.golang.org/godoc-documenting-go-code).

### Комментарии к документации

Все имена верхнего уровня, экспортируемые из пакета, должны иметь документационные комментарии, также как и объявления неэкспортируемых типов или функций, имеющих неочевидное поведение или значение. Эти комментарии должны быть [полными предложениями](https://google.github.io/styleguide/go/decisions#comment-sentences), начинающимися с названия описываемого объекта. Можно использовать артикль ("a", "an", "the") перед названием для более естественного чтения.
```
// Хорошо:
// Request представляет запрос для выполнения команды.
type Request struct { ...

// Encode записывает JSON-кодировку req в w.
func Encode(w io.Writer, req *Request) { ...
```
Документационные комментарии отображаются в [Godoc](https://pkg.go.dev/) и доступны в интегрированных средах разработки, и поэтому они должны быть написаны для всех, кто использует пакет.

Документационный комментарий применяется к следующему символу или группе полей в случае структуры.
```
// Хорошо:
// Options настраивает службу управления группой.
type Options struct {
    // Общая настройка:
    Name  string
    Group *FooGroup

    // Зависимости:
    DB *sql.DB

    // Пользовательские настройки:
    LargeGroupThreshold int // опциональный, по умолчанию: 10
    MinimumMembers      int // опциональный, по умолчанию: 2
}
```
**Лучшая практика:** Если у вас есть документационные комментарии для неэкспортируемого кода, следуйте тому же шаблону, как если бы он был экспортируемым (в частности, начинайте комментарий с неэкспортируемого имени). Это позволит легко экспортировать его позднее, просто заменив неэкспортируемое имя на новое экспортируемое в комментариях и коде.

### Предложения в комментариях

Комментарии, которые представляют собой полные предложения, должны быть написаны с заглавной буквы и знаком препинания, как в обычном английском предложении. (Исключение составляют случаи, когда предложение начинается с идентификатора, написанного с маленькой буквы, если его значение явно и понятно. Такие случаи, вероятно, лучше употреблять только в начале абзацев.)

Комментарии, которые являются фрагментами предложений, не требуют пунктуации или написания с заглавной буквы.

[Комментарии к документации](https://google.github.io/styleguide/go/decisions#doc-comments) должны всегда представлять собой полные предложения и, следовательно, должны начинаться с заглавной буквы и иметь знаки препинания. Простые комментарии в конце строки (особенно для полей в структурах) могут быть простыми фразами, начиная с предположения, что имя поля является подлежащим.

```
// Good:
// A Server handles serving quotes from the collected works of Shakespeare.
type Server struct {
    // BaseDir points to the base directory under which Shakespeare's works are stored.
    //
    // The directory structure is expected to be the following:
    //   {BaseDir}/manifest.json
    //   {BaseDir}/{name}/{name}-part{number}.txt
    BaseDir string

    WelcomeMessage  string // отображается при входе пользователя
    ProtocolVersion string // проверяется при входящих запросах
    PageLength      int    // количество строк на странице при печати (опционально, по умолчанию: 20)
}
```

### Примеры

Пакеты должны четко документировать предполагаемое использование. Старайтесь предоставить [запускаемый пример](http://blog.golang.org/examples); примеры отображаются в Godoc. Запускаемые примеры должны находиться в тестовом файле, а не в файле исходного кода продукции. Смотрите этот пример ([Godoc](https://pkg.go.dev/time#example-Duration), [исходный код](https://cs.opensource.google/go/go/+/HEAD:src/time/example_test.go)).

Если невозможно предоставить запускаемый пример, код примера можно указать в комментариях к коду. Как и другие фрагменты кода и командной строки в комментариях, он должен соответствовать стандартным соглашениям форматирования.

### Именованные параметры результата

При именовании параметров результата следует учитывать, как функции отображаются в Godoc. Само имя функции и тип параметров результата часто достаточно понятны.
```
// Хорошо:
func (n Node) Parent1() Node
func (n Node) Parent2() (Node, error)
```
Если функция возвращает два или более параметра одного типа, их именование может быть полезным.
```
// Хорошо:
func (n Node) Children() (left, right Node, err error)
```
Если вызывающая сторона должна предпринять действия в отношении конкретных параметров результата, их именование может помочь указать, какие действия требуются:
```
// Хорошо:
// WithTimeout возвращает контекст, который будет отменен не позднее, чем через
// заданное время d от текущего момента.
//
// Вызывающая сторона должна убедиться, что возвращенная функция cancel будет
// вызвана, когда контекст больше не нужен, чтобы избежать утечки ресурсов.
func WithTimeout(parent Context, d time.Duration) (ctx Context, cancel func())
```
В приведенном выше коде отмена - это конкретное действие, которое должна предпринять вызывающая сторона. Однако, если бы параметры результата были записаны просто как `(Context, func())`, было бы неясно, что имеется в виду под "функцией отмены".

Не используйте именованные параметры результата, когда имена вызывают [лишнее повторение](https://google.github.io/styleguide/go/decisions#repetitive-with-type).
```
// Плохо:
func (n Node) Parent1() (node Node)
func (n Node) Parent2() (node Node, err error)
```
Не именуйте параметры результата, чтобы избежать объявления переменных внутри функции. Эта практика приводит к ненужной избыточности API за счет незначительного укорочения кода.

[Именованные возвращаемые значения](https://tour.golang.org/basics/7) допустимы только в небольших функциях. Как только функция становится среднего размера, следует явно указывать возвращаемые значения. Аналогично, не именуйте параметры результата просто потому, что это позволяет использовать именованные возвращаемые значения. [Ясность](https://google.github.io/styleguide/go/guide#clarity) всегда важнее, чем экономия нескольких строк в функции.

Всегда допустимо именовать параметр результата, если его значение должно быть изменено в отложенном (deferred) замыкании.

> **Совет:** Типы часто могут быть более понятными, чем имена в сигнатуре функции. [GoTip #38: "Функции как именованные типы"](https://google.github.io/styleguide/go/index.html#gotip) демонстрирует это.
> 
> Опираясь на пример выше с [`WithTimeout`](https://pkg.go.dev/context#WithTimeout), настоящий код использует [`CancelFunc`](https://pkg.go.dev/context#CancelFunc) вместо простого `func()` в списке параметров результата и не требует больших усилий для документирования.

### Комментарии к пакету

Комментарии к пакету должны быть непосредственно над предложением пакета без пустой строки между комментарием и именем пакета. Пример:
```
// Хорошо:
// Пакет math предоставляет основные константы и математические функции.
//
// Этот пакет не гарантирует одинаковые результаты между архитектурами.
package math
```
В пакете должен быть один комментарий к пакету на каждый пакет. Если пакет состоит из нескольких файлов, ровно один из файлов должен содержать комментарий к пакету.

Комментарии для пакетов `main` имеют немного другую форму, где имя правила `go_binary` в файле BUILD заменяет имя пакета.
```
// Хорошо:
// Команда seed_generator - это утилита, которая генерирует файл симуляции Finch
// из набора JSON-конфигураций исследования.
package main
```
Другие стили комментариев допустимы, если имя двоичного файла соответствует имени, указанному в файле BUILD. Когда имя двоичного файла является первым словом, его следует писать с заглавной буквы, даже если оно не соответствует строго написанию командной строки.
```
// Хорошо:
// Двоичный файл seed_generator ...
// Команда seed_generator ...
// Программа seed_generator ...
// Команда seed_generator ...
// Программа seed_generator ...
// Seed_generator ...
```
Советы:

* Примеры командной строки и использования API могут быть полезной документацией. Для форматирования в Godoc следует добавить отступы перед строками комментария, содержащими код.
* Если нет очевидного основного файла или если комментарий к пакету является чрезвычайно длинным, можно поместить комментарий в файл с именем `doc.go`, содержащим только комментарий и предложение пакета.
* Многострочные комментарии можно использовать вместо нескольких однострочных комментариев. Это особенно полезно, если документация содержит разделы, которые можно скопировать и вставить из исходного файла, например, с примерами командной строки (для двоичных файлов) и примерами шаблонов.
```
// Хорошо:
/*
Команда seed_generator - это утилита, которая генерирует файл симуляции Finch
из набора JSON-конфигураций исследования.

    seed_generator *.json | base64 > finch-seed.base64
*/
package template
```
* Комментарии, предназначенные для сопровождающих и применимые к всему файлу, обычно размещаются после импорта. Они не отображаются в Godoc и не подчиняются правилам, указанным выше для комментариев к пакету.

## Импорты

### Переименование инпортов

Импорты должны переименовываться только для избежания конфликта имён с другими импортами. (Как следствие этого, [хорошие имена пакетов](https://google.github.io/styleguide/go/decisions#package-names) не должны требовать переименования.) В случае конфликта имён предпочтительно переименовывать наиболее локальный или специфичный для проекта импорт. Локальные имена (псевдонимы) для пакетов должны следовать [рекомендациям по именованию пакетов](https://google.github.io/styleguide/go/decisions#package-names), включая запрет на использование подчеркиваний и заглавных букв.

Сгенерированные пакеты протоколов (protocol buffer packages) должны быть переименованы для удаления подчеркиваний из их имен, и их псевдонимы должны иметь суффикс `pb`. См. [рекомендации по протоколам и транспортам](https://google.github.io/styleguide/go/best-practices#import-protos) для получения дополнительной информации.
```
// Хорошо:
import (
    fspb "path/to/package/foo_service_go_proto"
)
```
Импорты, у которых имена пакетов не содержат полезной идентификационной информации (например, `package v1`), должны быть переименованы, чтобы включать предыдущий компонент пути. Переименование должно быть согласовано с другими локальными файлами, импортирующими тот же пакет, и может включать номер версии.

**Примечание:** Желательно переименовывать пакеты так, чтобы они соответствовали [хорошим именам пакетов](https://google.github.io/styleguide/go/decisions#package-names), но это часто неосуществимо для пакетов в каталогах продавцов.
```
// Хорошо:
import (
    core "github.com/kubernetes/api/core/v1"
    meta "github.com/kubernetes/apimachinery/pkg/apis/meta/v1beta1"
)
```

Если вам нужно импортировать пакет, имя которого совпадает с общим именем локальной переменной, которую вы хотите использовать (например, `url`, `ssh`) и вы хотите переименовать пакет, предпочтительный способ сделать это - это добавить суффикс `pkg` (например, `urlpkg`). Обратите внимание, что пакет можно замаскировать локальной переменной; переименование необходимо только в случае, если пакет все еще должен использоваться, когда такая переменная находится в области видимости.

### Группировка импортов
Импорты должны быть организованы в две группы:
* Пакеты стандартной библиотеки
* Другие (проектные и пакеты от поставщиков)
```
// Хорошо:
package main

import (
    "fmt"
    "hash/adler32"
    "os"

    "github.com/dsnet/compress/flate"
    "golang.org/x/text/encoding"
    "google.golang.org/protobuf/proto"
    foopb "myproj/foo/proto/proto"
    _ "myproj/rpc/protocols/dial"
    _ "myproj/security/auth/authhooks"
)
```

Допускается разделение проектных пакетов на несколько групп, например, если вы хотите отдельную группу для переименованных, импортированных только для побочных эффектов или еще какую-то особую группу импортов.
```
// Хорошо:
package main

import (
    "fmt"
    "hash/adler32"
    "os"

    "github.com/dsnet/compress/flate"
    "golang.org/x/text/encoding"
    "google.golang.org/protobuf/proto"

    foopb "myproj/foo/proto/proto"

    _ "myproj/rpc/protocols/dial"
    _ "myproj/security/auth/authhooks"
)
```

**Примечание:** Поддержка необязательных подгрупп, таких как стандартная библиотека и импорты Google - не поддерживается инструментом [goimports](https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports). Дополнительные подгруппы импортов требуют внимания со стороны авторов и рецензентов для поддержания соответствующего состояния.

Программы Google, которые также являются приложениями AppEngine, должны иметь отдельную группу для импортов AppEngine.

Gofmt заботится о сортировке каждой группы по пути импорта. Однако он не разделяет импорты автоматически на группы. Популярный инструмент [goimports](https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports) объединяет Gofmt и управление импортами, разделяя импорты на группы на основе принятого решения. Допускается полностью доверить [goimports](https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports) управление порядком импортов, так что даже при изменении файла, его список импортов будет оставаться внутренне согласованным.

### Импорт "пустого" пакета (`import _`)

Пакеты, которые импортируются только для своих побочных эффектов (используя синтаксис `import _ "package"`), могут быть импортированы только в главный пакет или в тесты, которым они нужны.

Некоторые примеры таких пакетов включают:
* [time/tzdata](https://pkg.go.dev/time/tzdata)
* [image/jpeg](https://pkg.go.dev/image/jpeg) в коде обработки изображений

Избегайте пустых импортов в библиотечных пакетах, даже если библиотека зависит от них косвенно. Ограничение импортов с побочными эффектами до главного пакета помогает контролировать зависимости и позволяет писать тесты, основанные на другом импорте, без конфликтов или излишних затрат на сборку.

Следующий список является единственным исключением из этого правила:
* Вы можете использовать пустой импорт для обхода проверки на запрещенные импорты в [статическом анализаторе nogo](https://github.com/bazelbuild/rules_go/blob/master/go/nogo.rst).
* Вы можете использовать пустой импорт пакета [embed](https://pkg.go.dev/embed) в исходном файле, который использует компиляторную директиву `//go:embed`.

**Совет:** Если вы создаете библиотечный пакет, который косвенно зависит от импорта с побочными эффектами в продакшене, задокументируйте предполагаемое использование.

### Импорт "точка" (`import .`)

Форма `import .` - это возможность языка, позволяющая привносить идентификаторы, экспортируемые из другого пакета, в текущий пакет без квалификации. Дополнительную информацию см. в [спецификации языка](https://go.dev/ref/spec#Import_declarations).

**Не** используйте эту функцию в кодовой базе Google; это затрудняет определение, откуда идет функциональность.
```
// Плохо:
package foo_test

import (
    "bar/testutil" // также импортирует "foo"
    . "foo"
)

var myThing = Bar() // Bar определен в пакете foo; не требуется квалификация.
```
```
// Хорошо:
package foo_test

import (
    "bar/testutil" // также импортирует "foo"
    "foo"
)

var myThing = foo.Bar()
```

## Ошибки

### Возвращаемые ошибки

Используйте тип `error`, чтобы указать на возможность сбоя функции. Согласно соглашению, тип `error` должен быть последним параметром результата функции.
```
// Хорошо:
func Good() error { /* ... */ }
```

Возвращение `nil` в качестве ошибки является принятой практикой для сигнализации об успешной операции, которая может потенциально завершиться с ошибкой. Если функция возвращает ошибку, вызывающий код должен рассматривать все значения, возвращаемые функцией, кроме ошибки, как неопределенные, если явно не указано обратное в документации. Обычно значения, не являющиеся ошибкой, равны нулевым значениям своих типов, но на это нельзя полагаться.
```
// Хорошо:
func GoodLookup() (*Result, error) {
    // ...
    if err != nil {
        return nil, err
    }
    return res, nil
}
```

Экспортируемые функции, возвращающие ошибки, должны возвращать их с использованием типа `error`. Конкретные типы ошибок могут быть подвержены тонким ошибкам: конкретный указатель `nil` может быть обернут в интерфейс и, таким образом, стать ненулевым значением (см. раздел [FAQ по этой теме в документации Go](https://golang.org/doc/faq#nil_error)).
```
// Плохо:
func Bad() *os.PathError { /* ... */ }
```

**Совет:** Функция, принимающая аргумент `context.Context`, обычно должна возвращать ошибку, чтобы вызывающий код мог определить, был ли контекст отменен во время выполнения функции.

### Строковые ошибки

Строковые ошибки не должны быть написаны с заглавной буквы (за исключением случаев, когда они начинаются с экспортированного имени, собственного имени или аббревиатуры) и не должны заканчиваться знаками препинания. Это связано с тем, что строковые ошибки обычно появляются в контексте других сообщений до вывода пользователю.
```
// Плохо:
err := fmt.Errorf("Something bad happened.")
```
```
// Хорошо:
err := fmt.Errorf("something bad happened")
```

С другой стороны, стиль полного отображаемого сообщения (логирование, сообщение об ошибке в тесте, ответ от API или другой пользовательский интерфейс) может отличаться, но обычно должен быть написан с заглавной буквы.
```
// Хорошо:
log.Infof("Operation aborted: %v", err)
log.Errorf("Operation aborted: %v", err)
t.Errorf("Op(%q) failed unexpectedly; err=%v", args, err)
```

### Обработка ошибок

Код, который обнаруживает ошибку, должен принять осознанное решение о способе ее обработки. Обычно неправильно игнорировать ошибки с использованием `_` переменных. Если функция возвращает ошибку, выполните одно из следующих действий:

* Сразу обработайте и решите проблему с ошибкой.
* Верните ошибку вызывающему коду.
* В исключительных ситуациях можно вызвать [`log.Fatal`](https://pkg.go.dev/github.com/golang/glog#Fatal) или (если строго необходимо) `panic`.

**Примечание:** `log.Fatalf` не является частью стандартной библиотеки log. См. раздел [Логирование](https://google.github.io/styleguide/go/decisions#logging).

В редких случаях, когда допустимо игнорировать или отбросить ошибку (например, при вызове записи (*bytes.Buffer).Write, который по документации никогда не вызывает ошибку), сопровождающий комментарий должен объяснить причины безопасности такого действия.
```
// Хорошо:
var b *bytes.Buffer

n, _ := b.Write(p) // никогда не возвращает ошибку, которая не равна nil
```

Для более обширного обсуждения и примеров обработки ошибок смотрите [Effective Go](http://golang.org/doc/effective_go.html#errors) и [лучшие практики](https://google.github.io/styleguide/go/best-practices.html#error-handling).

### Встроенные ошибки (In-band)

В языке С и аналогичных языках часто функции возвращают значения, такие как -1, null или пустую строку, чтобы сигнализировать об ошибках или отсутствии результатов. Это называется обработкой ошибок внутри диапазона значений.
```
// Плохо:
// Lookup возвращает значение для ключа или -1, если нет соответствия для ключа.
func Lookup(key string) int
```

Отзказ от проверки возвращаемого значения ошибки внутри диапазона значений может привести к неправильному присвоению ошибок функции.
```
// Плохо:
// Следующая строка возвращает ошибку о том, что разбор не удался для входного значения,
// хотя ошибка заключается в том, что нет соответствия для missingKey.
return Parse(Lookup(missingKey))
```

Более хорошим решением является использование возможности Go для возвращения нескольких значений (см. раздел [Effective Go о множественных возвращаемых значениях](http://golang.org/doc/effective_go.html#multiple-returns)). Вместо того, чтобы требовать от клиентского кода проверять возвращаемое значение ошибки внутри диапазона значений, функция должна возвращать дополнительное значение, указывающее, являются ли ее другие возвращаемые значения действительными. Это может быть значение типа error или булево значение, когда не требуется дополнительное пояснение, и должно быть последним возвращаемым значением.
```
// Хорошо:
// Lookup возвращает значение для ключа или ok=false, если нет соответствия для ключа.
func Lookup(key string) (value string, ok bool)
```

Такой интерфейс предотвращает неправильное написание `Parse(Lookup(key))`, что приводит к ошибке во время компиляции, поскольку `Lookup(key)` имеет 2 выходных значения.

Возврат ошибок таким образом поощряет более надежную и явную обработку ошибок:
```
// Хорошо:
value, ok := Lookup(key)
if !ok {
    return fmt.Errorf("no value for %q", key)
}
return Parse(value)
```

Некоторые функции стандартной библиотеки, такие как те в пакете `strings`, возвращают ошибки внутри диапазона значений. Это значительно упрощает код для работы со строками, но требует большей внимательности от программиста. В целом код на Go в кодовой базе Google должен возвращать дополнительные значения для ошибок.

### Идентичная обработка ошибок

Обработайте ошибки перед продолжением выполнения остального кода. Это улучшает читаемость кода, позволяя читателю быстро перейти к нормальному пути выполнения. Та же логика применима к любому блоку, который проверяет условие, а затем заканчивается завершающим условием (например, `return`, `panic`, `log.Fatal`).

Код, который выполняется, если завершающее условие не выполняется, должен находиться после блока `if`, и не должен быть вложен в блок `else`.
```
// Хорошо:
if err != nil {
    // обработка ошибки
    return // или continue и т.д.
}
// нормальный код
```
```
// Плохо:
if err != nil {
    // обработка ошибки
} else {
    // нормальный код, который выглядит необычно из-за отступов
}
```

> **Совет:** Если вы используете переменную на протяжении нескольких строк кода, то обычно нет смысла использовать стиль if с инициализатором. В таких случаях лучше поместите объявление переменной вне блока и используйте стандартный оператор if:
>```
> // Хорошо:
> x, err := f()
> if err != nil {
>   // обработка ошибки
>   return
> }
> // множество кода, использующего x
> // на протяжении нескольких строк
>```
>```
> // Плохо:
> if x, err := f(); err != nil {
>  // обработка ошибки
>  return
>} else {
>  // множество кода, использующего x
>  // на протяжении нескольких строк
>}
>```


Для получения дополнительных деталей смотрите ["Совет по Go #1: Линия прямой видимости"](https://google.github.io/styleguide/go/index.html#gotip) и ["TotT: Уменьшите сложность кода за счет уменьшения вложенности"](https://testing.googleblog.com/2017/06/code-health-reduce-nesting-reduce.html).

## Язык

### Форматирование литералов
В Go существует очень мощный [синтаксис составных литералов](https://golang.org/ref/spec#Composite_literals), с помощью которого можно выразить сложные вложенные значения в одном выражении. По возможности следует использовать этот синтаксис литералов вместо построения значений поле за полем. Обычно `gofmt` форматирует литералы достаточно хорошо, но есть некоторые дополнительные правила для поддержания читабельности и поддерживаемости этих литералов.

#### Имена полей
Структурные литералы обычно должны указывать **имена полей** для типов, определенных вне текущего пакета.

* Включите имена полей для типов из других пакетов.
    ```
    // Хорошо:
    good := otherpkg.Type{A: 42}
    ```

    Положение полей в структуре и полный набор полей (которые являются необходимыми при опущенных именах полей) обычно не считаются частью публичного API структуры. Указание имени поля необходимо, чтобы избежать ненужной связанности.
    ```
    // Плохо:
    // https://pkg.go.dev/encoding/csv#Reader
    r := csv.Reader{',', '#', 4, false, false, false, false}
    ```

    Имена полей могут быть опущены при маленьких и простых структурах, чье составление и порядок документируются как стабильные.
    ```
    // Хорошо:
    okay := image.Point{42, 54}
    also := image.Point{X: 42, Y: 54}
    ```

* Для типов из текущего пакета имена полей являются опциональными.
    ```
    // Хорошо:
    okay := Type{42}
    also := internalType{4, 2}
    ```
    
    Имена полей следует использовать, если они делают код более понятным, и это очень распространено. Например, структура с большим количеством полей практически всегда должна инициализироваться с использованием имен полей.
    ```
    // Хорошо:
    okay := StructWithLotsOfFields{
      field1: 1,
      field2: "two",
      field3: 3.14,
      field4: true,
    }
    ```

#### Согласование фигурных скобок

Закрывающая половина пары фигурных скобок должна всегда находиться на той же строке с таким же отступом, что и открывающая фигурная скобка. У однострочных литералов это свойство выполняется автоматически. Когда литерал занимает несколько строк, поддержание этого свойства сохраняет согласованность фигурных скобок для литералов такой же, как для обычных конструкций на Go, таких как функции и условия `if`.

Наиболее распространенной ошибкой в этой области является помещение закрывающей скобки на ту же строку, что и значение в многострочном структурном литерале. В таких случаях строка должна заканчиваться запятой, и закрывающая скобка должна появиться на следующей строке.
```
// Хорошо:
good := []*Type{{Key: "value"}}
```
```
// Хорошо:
good := []*Type{
    {Key: "multi"},
    {Key: "line"},
}
```
```
// Плохо:
bad := []*Type{
    {Key: "multi"},
    {Key: "line"}}
```
```
// Плохо:
bad := []*Type{
    {
        Key: "value"},
}
```

#### Объятия фигурных скобок
Отбрасывание пробелов между фигурными скобками (их "Объятие") для литералов срезов и массивов разрешено только в том случае, если справедливы оба следующих условия:

* [Отступ совпадает](https://google.github.io/styleguide/go/decisions#literal-matching-braces).
* Внутренние значения также являются литералами или построителями протокола (то есть не являются переменными или другими выражениями).
```
// Хорошо:
good := []*Type{
    { // Не объято
        Field: "value",
    },
    {
        Field: "value",
    },
}
```
```
// Хорошо:
good := []*Type{{ // Объятие выполнено правильно
    Field: "value",
}, {
    Field: "value",
}}
```
```
// Хорошо:
good := []*Type{
    first, // Не может быть объято
    {Field: "second"},
}
```
```
// Хорошо:
okay := []*pb.Type{pb.Type_builder{
    Field: "first", // Построители протокола могут быть объяты, чтобы сохранить вертикальное пространство
}.Build(), pb.Type_builder{
    Field: "second",
}.Build()}
```
```
// Плохо:
bad := []*Type{
    first,
    {
        Field: "second",
    }}
```

#### Повторяющиеся имена типов
Повторяющиеся имена типов могут быть опущены в литералах срезов и карт. Это может помочь уменьшить перемешивание. Разумным моментом для явного повторения имен типов является работа с сложными типами, которые не так часто встречаются в вашем проекте, когда повторяющиеся имена типов находятся на далеко разнесенных строках и могут напомнить читателю о контексте.
```
// Хорошо:
good := []*Type{
    {A: 42},
    {A: 43},
}
```
```
// Плохо:
repetitive := []*Type{
    &Type{A: 42},
    &Type{A: 43},
}
```
```
// Хорошо:
good := map[Type1]*Type2{
    {A: 1}: {B: 2},
    {A: 3}: {B: 4},
}
```
```
// Плохо:
repetitive := map[Type1]*Type2{
    Type1{A: 1}: &Type2{B: 2},
    Type1{A: 3}: &Type2{B: 4},
}
```

**Совет:** Если вы хотите убрать повторяющиеся имена типов в литералах структур, вы можете использовать команду `gofmt -s`.

#### Поля с нулевыми значениями
[Поля с нулевыми значениями](https://golang.org/ref/spec#The_zero_value) могут быть опущены при создании литералов структур, если это не влияет на ясность кода.

Хорошо разработанные API часто используют конструирование с нулевыми значениями для улучшения читабельности кода. Например, опуская три поля со значением ноль в следующей структуре, обращается внимание только на определенный параметр.
```
// Плохо:
import (
  "github.com/golang/leveldb"
  "github.com/golang/leveldb/db"
)

ldb := leveldb.Open("/my/table", &db.Options{
    BlockSize: 1<<16,
    ErrorIfDBExists: true,

    // Все эти поля имеют значения по умолчанию.
    BlockRestartInterval: 0,
    Comparer: nil,
    Compression: nil,
    FileSystem: nil,
    FilterPolicy: nil,
    MaxOpenFiles: 0,
    WriteBufferSize: 0,
    VerifyChecksums: false,
})
```
```
// Хорошо:
import (
  "github.com/golang/leveldb"
  "github.com/golang/leveldb/db"
)

ldb := leveldb.Open("/my/table", &db.Options{
    BlockSize: 1<<16,
    ErrorIfDBExists: true,
})
```

Структуры в таблице-проводнике тестов часто выгодно использовать [явные имена полей](https://google.github.io/styleguide/go/decisions#literal-field-names), особенно когда структура теста не является тривиальной. Это позволяет автору полностью опустить поля с нулевыми значениями, когда эти поля не относятся к конкретному тестовому случаю. Например, успешные тестовые случаи должны опускать все поля, связанные с ошибками или сбоями. В случаях, когда нулевое значение необходимо для понимания тестового случая, например, для тестирования нулевого или `nil` ввода, следует указывать имена полей.

**Краткий способ**
```
tests := []struct {
    input      string
    wantPieces []string
    wantErr    error
}{
    {
        input:      "1.2.3.4",
        wantPieces: []string{"1", "2", "3", "4"},
    },
    {
        input:   "hostname",
        wantErr: ErrBadHostname,
    },
}
```

**Явный способ**
```
tests := []struct {
    input    string
    wantIPv4 bool
    wantIPv6 bool
    wantErr  bool
}{
    {
        input:    "1.2.3.4",
        wantIPv4: true,
        wantIPv6: false,
    },
    {
        input:    "1:2::3:4",
        wantIPv4: false,
        wantIPv6: true,
    },
    {
        input:    "hostname",
        wantIPv4: false,
        wantIPv6: false,
        wantErr:  true,
    },
}
```

### Нуллевые срезы (Nil slices)
В большинстве случаев между `nil` и пустым срезом нет функциональной разницы. Встроенные функции, такие как `len` и `cap`, ведут себя ожидаемым образом с нулевыми срезами.
```
// Хорошо:
import "fmt"

var s []int         // nil

fmt.Println(s)      // []
fmt.Println(len(s)) // 0
fmt.Println(cap(s)) // 0
for range s {...}   // no-op

s = append(s, 42)
fmt.Println(s)      // [42]
```

Если вы объявляете пустой срез в качестве локальной переменной (особенно если он может быть возвращаемым значением), предпочтительнее использовать инициализацию с `nil`, чтобы уменьшить риск возникновения ошибок у вызывающего кода.
```
// Хорошо:
var t []string
```
```
// Плохо:
t := []string{}
```

Не создавайте такие API, которые заставляют клиентов делать различие между `nil` и пустым срезом.

```
// Хорошо:
// Ping пингует указанные цели.
// Возвращает хосты, успешно ответившие.
func Ping(hosts []string) ([]string, error) { ... }
```
```
// Плохо:
// Ping пингует указанные цели и возвращает список хостов,
// успешно ответивших. Может быть пустым, если входной срез пуст.
// nil указывает на то, что произошла системная ошибка.
func Ping(hosts []string) []string { ... }
```

При проектировании интерфейсов старайтесь не делать различий между `nil`-срезом и пустым срезом, так как это может привести к тонким ошибкам программирования. Обычно это достигается с помощью оператора `len` для проверки пустоты, а не сравнения с `nil`.

В этой реализации как `nil`, так и срез нулевой длины принимаются как «пустые»:
```
// Хорошо:
// describeInts описывает s с заданным префиксом, если s не пустой.
func describeInts(prefix string, s []int) {
    if len(s) == 0 {
        return
    }
    fmt.Println(prefix, s)
}
```

Вместо полаганияс различие становится частью API:
```
// Плохо:
func maybeInts() []int { /* ... */ }

// describeInts описывает s с заданным префиксом; передайте nil, чтобы полностью пропустить.
func describeInts(prefix string, s []int) {
  // Поведение этой функции намеренно меняется в зависимости от того, что
  // maybeInts() возвращает в 'пустых' случаях (nil или []int{}).
  if s == nil {
    return
  }
  fmt.Println(prefix, s)
}

describeInts("Вот некоторые целые числа:", maybeInts())
```
Смотрите также [Встроенные ошибки](https://google.github.io/styleguide/go/decisions#in-band-errors) для дальнейшего обсуждения.

### Ошибки при форматировании отступов
Избегайте ввода переноса строки, если это выравнивает остаток строки с блоком кода, имеющим отступ. Если такое совпадение невозможно, оставьте пробел для разделения кода в блоке от перенесенной строки.
```
// Плохо:
if longCondition1 && longCondition2 &&
    // Условия 3 и 4 имеют такой же отступ, как код внутри if.
    longCondition3 && longCondition4 {
    log.Info("выполнены все условия")
}
```

См. следующие разделы для конкретных рекомендаций и примеров:

* [Форматирование функций](https://google.github.io/styleguide/go/decisions#func-formatting)
* [Условные выражения и циклы](https://google.github.io/styleguide/go/decisions#conditional-formatting)
* [Форматирование литералов](https://google.github.io/styleguide/go/decisions#literal-formatting)

### Форматирование функций
В объявлении функции или метода сигнатура должна оставаться на одной строке, чтобы избежать [путаницы с отступами](https://google.github.io/styleguide/go/decisions#indentation-confusion).

Списки аргументов функций могут занимать самые длинные строки в исходном файле на Go. Однако они предшествуют изменению отступа, поэтому трудно разбить строку таким образом, чтобы остальные строки не выглядели как часть тела функции в непонятном виде:
```
// Плохо:
func (r *SomeType) SomeLongFunctionName(foo1, foo2, foo3 string,
    foo4, foo5, foo6 int) {
    foo7 := bar(foo1)
    // ...
}
```

См. [лучшие практики](https://google.github.io/styleguide/go/best-practices#funcargs), чтобы узнать о нескольких вариантах сокращения вызовов функций, которые в противном случае имели бы много аргументов.
```
// Хорошо:
good := foo.Call(long, CallOptions{
    Names:   list,
    Of:      of,
    The:     parameters,
    Func:    all,
    Args:    on,
    Now:     separate,
    Visible: lines,
})
```
```
// Плохо:
bad := foo.Call(
    long,
    list,
    of,
    parameters,
    all,
    on,
    separate,
    lines,
)
```

Строки часто можно сократить путем выноса локальных переменных.
```
// Хорошо:
local := helper(some, parameters, here)
good := foo.Call(list, of, parameters, local)
```

Аналогично, вызовы функций и методов не должны разделяться исключительно на основе длины строки.
```
// Хорошо:
good := foo.Call(long, list, of, parameters, all, on, one, line)
```
```
// Плохо:
bad := foo.Call(long, list, of, parameters,
    with, arbitrary, line, breaks)
```


Не добавляйте комментарии к конкретным параметрам функции. Вместо этого используйте [структуру параметров](https://google.github.io/styleguide/go/best-practices#option-structure) или добавьте более подробную информацию в документацию функции.
```
// Хорошо:
good := server.New(ctx, server.Options{Port: 42})
```
```
// Плохо:
bad := server.New(
    ctx,
    42, // Порт
)
```


Если вызовы являются неудобно длинными, рассмотрите возможность рефакторинга.
```
// Хорошо:
// Иногда вариативные аргументы могут быть вынесены
replacements := []string{
    "из", "в", // связанные значения могут быть отформатированы рядом друг с другом
    "исходный", "исправленный",
}

// Используйте структуру replacements в качестве входных данных для NewReplacer.
replacer := strings.NewReplacer(replacements...)
```

Если API невозможно изменить или если локальный вызов необычен (независимо от того, является ли вызов слишком длинным), всегда допустимо добавлять переносы строк, если это помогает понять вызов.

```
// Хорошо:
canvas.RenderCube(cube,
    x0, y0, z0,
    x0, y0, z1,
    x0, y1, z0,
    x0, y1, z1,
    x1, y0, z0,
    x1, y0, z1,
    x1, y1, z0,
    x1, y1, z1,
)
```

Обратите внимание, что строки в приведенном выше примере не переносятся на определенном столбце, а группируются на основе троек координат.

Длинные строковые литералы внутри функций не должны разбиваться из-за длины строки. Для функций, которые содержат такие строки, после форматирования строки можно добавить перенос строки, а аргументы можно указать на следующих или последующих строках. Решение о том, где должны быть разделены строки, лучше принимать на основе семантической группировки входных данных, а не только на основе длины строки.
```
// Хорошо:
log.Warningf("Database key (%q, %d, %q) incompatible in transaction started by (%q, %d, %q)",
    currentCustomer, currentOffset, currentKey,
    txCustomer, txOffset, txKey)
```
```
// Плохо:
log.Warningf("Database key (%q, %d, %q) incompatible in"+
    " transaction started by (%q, %d, %q)",
    currentCustomer, currentOffset, currentKey, txCustomer,
    txOffset, txKey)
```

### Условные операторы и циклы
Оператор `if` не должен разбиваться на несколько строк; многострочные условия `if` могут вызывать [путаницу в отступах](https://google.github.io/styleguide/go/decisions#indentation-confusion).
```
// Плохо:
// Второй оператор if выровнен с кодом внутри блока if, вызывая путаницу в отступах.
if db.CurrentStatusIs(db.InTransaction) &&
    db.ValuesEqual(db.TransactionKey(), row.Key()) {
    return db.Errorf(db.TransactionError, "query failed: row (%v): key does not match transaction key", row)
}
```

Если короткозамыкающее поведение не требуется, булевские операнды могут быть извлечены напрямую:
```
// Хорошо:
inTransaction := db.CurrentStatusIs(db.InTransaction)
keysMatch := db.ValuesEqual(db.TransactionKey(), row.Key())
if inTransaction && keysMatch {
    return db.Error(db.TransactionError, "query failed: row (%v): key does not match transaction key", row)
}
```
Также могут быть другие локальные переменные, особенно если условие уже повторяется:
```
// Хорошо:
uid := user.GetUniqueUserID()
if db.UserIsAdmin(uid) db.UserHasPermission(uid, perms.ViewServerConfig) db.UserHasPermission(uid, perms.CreateGroup) {
    // ...
}
```
```
// Плохо:
if db.UserIsAdmin(user.GetUniqueUserID()) db.UserHasPermission(user.GetUniqueUserID(), perms.ViewServerConfig) db.UserHasPermission(user.GetUniqueUserID(), perms.CreateGroup) {
    // ...
}
```

Операторы `if`, содержащие замыкания или многострочные литералы структур, должны проверять, чтобы [фигурные скобки соответствовали друг другу](https://google.github.io/styleguide/go/decisions#literal-matching-braces), чтобы избежать [путаницы в отступах](https://google.github.io/styleguide/go/decisions#indentation-confusion).

```
// Хорошо:
if err := db.RunInTransaction(func(tx *db.TX) error {
    return tx.Execute(userUpdate, x, y, z)
}); err != nil {
    return fmt.Errorf("user update failed: %s", err)
}
```
```
// Хорошо:
if _, err := client.Update(ctx, &upb.UserUpdateRequest{
    ID:   userID,
    User: user,
}); err != nil {
    return fmt.Errorf("user update failed: %s", err)
}
```

Также не пытайтесь вставлять искусственные переносы строк в операторы `for`. Всегда можно просто оставить строку длинной, если нет элегантного способа перестроить ее:
```
// Хорошо:
for i, max := 0, collection.Size(); i < max && !collection.HasPendingWriters(); i++ {
    // ...
}
```
Однако часто появляется:
```
// Хорошо:
for i, max := 0, collection.Size(); i < max; i++ {
    if collection.HasPendingWriters() {
        break
    }
    // ...
}
```
Операторы `switch` и `case` также должны быть находиться в одной строке.
```
// Хорошо:
switch good := db.TransactionStatus(); good {
case db.TransactionStarting, db.TransactionActive, db.TransactionWaiting:
    // ...
case db.TransactionCommitted, db.NoTransaction:
    // ...
default:
    // ...
}
```
```
// Плохо:
switch bad := db.TransactionStatus(); bad {
case db.TransactionStarting,
    db.TransactionActive,
    db.TransactionWaiting:
    // ...
case db.TransactionCommitted,
    db.NoTransaction:
    // ...
default:
    // ...
}
```
Если строка чрезмерно длинная, отступите все случаи и отделите их пустой строкой, чтобы избежать [путаницы в отступах](https://google.github.io/styleguide/go/decisions#indentation-confusion):
```
// Хорошо:
switch db.TransactionStatus() {
case
    db.TransactionStarting,
    db.TransactionActive,
    db.TransactionWaiting,
    db.TransactionCommitted:

    // ...
case db.NoTransaction:
    // ...
default:
    // ...
}
```
В условных операторах, сравнивающих переменную с константой, помещайте значение переменной слева от оператора равенства:
```
// Хорошо:
if result == "foo" {
  // ...
}
```
Вместо менее понятного фразирования, где константа идет первой (["условия в стиле Йоды"](https://en.wikipedia.org/wiki/Yoda_conditions)):
```
// Плохо:
if "foo" == result {
  // ...
}
```

### Копирование

Чтобы избежать неожиданного копирования и подобных ошибок, будьте осторожны при копировании структуры из другого пакета. Например, объекты синхронизации, такие как `sync.Mutex`, не должны копироваться.

Тип `bytes.Buffer` содержит срез `[]byte` и, для оптимизации работы со строками малого размера, небольшой байтовый массив, на который может ссылаться срез. Если вы копируете `Buffer`, срез в копии может ссылаться на массив в оригинале, что может приводить к неожиданным эффектам при вызове методов.

Вообще говоря, не копируйте значение типа `T`, если его методы ассоциированы с типом указателя `*T`.
```
// Плохо:
b1 := bytes.Buffer{}
b2 := b1
```
Вызов метода, который принимает значение в качестве получателя, может скрыть копию. Когда вы разрабатываете API, вы обычно должны использовать указатели в качестве параметров и возвращаемых значений, если ваши структуры содержат поля, которые не должны копироваться.

Это примеры приемлемого использования:
```
// Хорошо:
type Record struct {
  buf bytes.Buffer
  // другие поля опущены
}

func New() *Record {...}

func (r *Record) Process(...) {...}

func Consumer(r *Record) {...}
```
Но следующее обычно неправильно:
```
// Плохо:
type Record struct {
  buf bytes.Buffer
  // другие поля опущены
}

func (r Record) Process(...) {...} // Создает копию r.buf

func Consumer(r Record) {...} // Создает копию r.buf
```
Эти рекомендации также относятся к копированию `sync.Mutex`.


### Не паникуйте

Не используйте `panic` для обработки нормальных ошибок. Вместо этого используйте `error` и множественные возвращаемые значения. См. раздел [Effective Go об ошибках](http://golang.org/doc/effective_go.html#errors).

В коде пакета `main` и коде инициализации рассмотрите использование [`log.Exit`](https://pkg.go.dev/github.com/golang/glog#Exit) для ошибок, которые должны привести к завершению программы (например, некорректная конфигурация), так как в таких случаях трассировка стека не поможет разработчику. Обратите внимание, что [`log.Exit`](https://pkg.go.dev/github.com/golang/glog#Exit) вызывает [`os.Exit`](https://pkg.go.dev/os#Exit), и отложенные функции не будут выполнены.

Для ошибок, которые указывают на "невозможные" условия, то есть на ошибки, которые всегда должны быть обнаружены при рассмотрении кода и/или тестировании, функция может разумно возвращать ошибку или вызывать [`log.Fatal`](https://pkg.go.dev/github.com/golang/glog#Fatal).

**Примечание:** `log.Fatalf` не является частью стандартной библиотеки `log`. См. раздел [Логирование](https://google.github.io/styleguide/go/decisions#logging).

### Обязательные функции
Вспомогательные функции настройки, которые останавливают программу в случае ошибки, следуют соглашению об именовании `MustXYZ` (или `mustXYZ`). В целом, их следует вызывать только в самом начале запуска программы, а не в случае, например, пользовательского ввода, где предпочтительна обычная обработка ошибок Go.

Это часто применяется для функций, вызываемых для инициализации переменных на уровне пакета исключительно во время инициализации пакета (например, `template.Must` и `regexp.MustCompile`).
```
// Хорошо:
func MustParse(version string) *Version {
    v, err := Parse(version)
    if err != nil {
        log.Fatalf("MustParse(%q) = _, %v", version, err)
    }
    return v
}

// "Константа" на уровне пакета. Если мы хотели использовать Parse, мы должны были бы установить значение в init.
var DefaultVersion = MustParse("1.2.3")
```
**Примечание:** `log.Fatalf` не является частью стандартной библиотеки `log`. См. раздел [Логирование](https://google.github.io/styleguide/go/decisions#logging).

То же самое соглашение может использоваться в тестовых утилитах, которые просто останавливают текущий тест (с помощью `t.Fatal`). Такие утилиты часто удобны при создании тестовых значений, например, в полях структур при использовании [таблицы тестов](https://google.github.io/styleguide/go/decisions#table-driven-tests), поскольку функции, возвращающие ошибки, не могут быть непосредственно присвоены полю структуры.
```
// Хорошо:
func mustMarshalAny(t testing.T, m proto.Message) anypb.Any {
  t.Helper()
  any, err := anypb.New(m)
  if err != nil {
    t.Fatalf("MustMarshalAny(t, m) = %v; want %v", err, nil)
  }
  return any
}
```
```
func TestCreateObject(t *testing.T) {
  tests := []struct{
    desc string
    data *anypb.Any
  }{
    {
      desc: "my test case",
      // Creating values directly within table driven test cases.
      data: mustMarshalAny(t, mypb.Object{}),
    },
    // ...
  }
  // ...
}
```
В обоих случаях значение этого шаблона в том, что утилиты могут быть вызваны в "контексте значения". Эти утилиты не следует вызывать в местах, где сложно гарантировать перехват ошибки или в контексте, где ошибку следует [проверять](https://google.github.io/styleguide/go/decisions#handle-errors) (например, во многих обработчиках запросов). В случае постоянных входных данных, это позволяет легко убедиться, что аргументы `Must` имеют правильную структуру, а для не постоянных входных данных это позволяет проверить, что ошибки [обрабатываются или передаются правильно](https://google.github.io/styleguide/go/best-practices#error-handling).

Если `Must` функции используются в тесте, их следует, как правило, пометить как [вспомогательные функции для тестов](https://google.github.io/styleguide/go/decisions#mark-test-helpers) и вызывать `t.Fatal` при возникновении ошибки (см. обработку ошибок в вспомогательных функциях для тестов для более детального рассмотрения этого вопроса).

Их не следует использовать, когда возможна [обычная обработка ошибок](https://google.github.io/styleguide/go/best-practices#error-handling) (включая возможность некоторого рефакторинга):
```
// Плохо:
func Version(o servicepb.Object) (version.Version, error) {
    // Возврат ошибки вместо использования Must функций.
    v := version.MustParse(o.GetVersionString())
    return dealiasVersion(v)
```

### Время жизни горутины

Когда вы создаете горутину, убедитесь, будет ли она завершена, и если да, то когда.

Горутины могут простаивать, если они блокируются на отправке или получении из канала. Сборщик мусора не завершает горутину, даже если каналы, на которых она блокирована, недоступны.

Даже если горутины не простаивают, оставление их в "полете", когда они больше не нужны, может вызвать другие тонкие и сложные проблемы, которые трудно диагностировать. Отправка в закрытый канал вызывает панику.
```
// Плохой пример:
ch := make(chan int)
ch <- 42
close(ch)
ch <- 13 // паника
```
Изменение входных данных, которые "уже не требуются", может привести к гонкам данных. Оставление горутин в "полете" на неопределенное время может привести к непредсказуемому использованию памяти.

Код, работающий параллельно, должен быть написан таким образом, чтобы время жизни горутин было явным. Обычно это означает ограничение кода синхронизации в рамках функции и разделение логики на [синхронные функции](https://google.github.io/styleguide/go/decisions#synchronous-functions). Если параллельность все равно не очевидна, важно задокументировать, когда и почему горутины завершаются.

Код, который следует лучшим практикам использования контекста, часто помогает сделать это понятным. Обычно он управляется с помощью `context.Context`:

```
// Хороший пример:
func (w *Worker) Run(ctx context.Context) error {
    // ...
    for item := range w.q {
        // process завершается, как только контекст отменен.
        go process(ctx, item)
    }
    // ...
}
```
Существуют другие варианты использования "сырых" сигнальных каналов, таких как `chan struct{}`, синхронизированных переменных, [условных переменных](https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view) и так далее. Главное, чтобы конец горутины был явен для последующих разработчиков.

В отличие от этого, следующий код не задумывается о том, когда его созданные горутины завершаются:
```
// Плохой пример:
func (w *Worker) Run() {
    // ...
    for item := range w.q {
        // process завершается, когда оно закончится, если вообще закончится,
        // возможно, не обрабатывая корректно переход состояния или завершение самой программы на Go.
        go process(item)
    }
    // ...
}
```
Этот код может выглядеть нормально, но в нем есть несколько проблем:
* Вероятно, код имеет неопределенное поведение в продакшене, и программа может не завершиться корректно, даже если операционная система освободит ресурсы.
* Код трудно осмысленно тестировать из-за неопределенного жизненного цикла кода.
* Из кода могут утекать ресурсы, как описано выше.

Смотрите также:
* [Не запускайте горутину, не зная, как она будет останавливаться](https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop)
* Переосмысление классических шаблонов параллелизма: [слайды](https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view), [видео](https://www.youtube.com/watch?v=5zXAHh5tJqQ)
* [Когда Go программы завершаются](https://changelog.com/gotime/165)

### Интерфейсы 

Обычно интерфейсы Go должны находиться в пакете, который использует значения типа интерфейса, а не в пакете, который реализует тип интерфейса. Реализующий пакет должен возвращать конкретные типы (обычно указатель или структуру). Таким образом, новые методы могут быть добавлены в реализации без необходимости обширного рефакторинга. Для получения более подробной информации смотрите [Совет по Go #49: Принимайте интерфейсы, возвращайте конкретные типы](https://google.github.io/styleguide/go/index.html#gotip).

Не экспортируйте реализацию [тестовой заглушки](https://abseil.io/resources/swe-book/html/ch13.html#techniques_for_using_test_doubles) интерфейса из API, которое его использует. Вместо этого спроектируйте API так, чтобы его можно было протестировать, используя [публичное API](https://abseil.io/resources/swe-book/html/ch12.html#test_via_public_apis) [реальной реализации](https://google.github.io/styleguide/go/best-practices#use-real-transports). Для получения более подробной информации смотрите [Совет по Go #42: Создание заглушки для тестирования](https://google.github.io/styleguide/go/index.html#gotip). Даже когда невозможно использовать реальную реализацию, не всегда необходимо создавать интерфейс, полностью описывающий все методы реального типа; потребитель может создать интерфейс, содержащий только нужные ему методы, как показано в [Совет по Go #78: Минимально жизнеспособные интерфейсы](https://google.github.io/styleguide/go/index.html#gotip).

Для тестирования пакетов, которые используют клиенты Stubby RPC, используйте реальное подключение клиента. Если невозможно запустить реальный сервер в тесте, Google рекомендует использовать реальное подключение клиента к локальной [тестовой заглушке](https://abseil.io/resources/swe-book/html/ch13.html#basic_concepts) с помощью внутреннего пакета `rpctest` (скоро появится!).

Не определяйте интерфейсы до их использования (см. [TotT: Код здоровья: Устраните запахи YAGNI](https://testing.googleblog.com/2017/08/code-health-eliminate-yagni-smells.html)). Без реалистичного примера использования трудно определить, нужен ли интерфейс и какие методы он должен содержать.

Не используйте параметры с типом интерфейса, если пользователям пакета не нужно передавать разные типы данных.

Не экспортируйте интерфейсы, которые необходимы только пользователю пакета.

TODO: Напишите более подробную документацию об интерфейсах и добавьте ссылку сюда.
```
// Хороший пример:
package consumer // consumer.go

type Thinger interface { Thing() bool }

func Foo(t Thinger) string { ... }
```
```
// Хороший пример:
package consumer // consumer_test.go

type fakeThinger struct{ ... }
func (t fakeThinger) Thing() bool { ... }
...
if Foo(fakeThinger{...}) == "x" { ... }
// Плохой пример:
package producer

type Thinger interface { Thing() bool }

type defaultThinger struct{ ... }
func (t defaultThinger) Thing() bool { ... }

func NewThinger() Thinger { return defaultThinger{ ... } }
```
```
// Хороший пример:
package producer

type Thinger struct{ ... }
func (t Thinger) Thing() bool { ... }

func NewThinger() Thinger { return Thinger{ ... } }
```

### Дженерики
