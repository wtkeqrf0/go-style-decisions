# [Руководство по стилю](https://google.github.io/styleguide/)

# Стили Go кода

Ссылка на оригинальную статью: [https://google.github.io/styleguide/go/decisions](https://google.github.io/styleguide/go/decisions)

[Обзор](https://google.github.io/styleguide/go/index) | [Руководство](https://google.github.io/styleguide/go/guide) | [Решения](https://google.github.io/styleguide/go/decisions) | [Лучшие практики](https://google.github.io/styleguide/go/best-practices)

> Это часть серии документов, описывающих [стиль Go](https://google.github.io/styleguide/go/index) в Google. Этот документ является **[нормативным](https://google.github.io/styleguide/go/index#normative), но не [каноническим](https://google.github.io/styleguide/go/index#canonical)** и подчиняется основному [руководству по стилю](https://google.github.io/styleguide/go/guide). Пожалуйста, см. [обзор](https://google.github.io/styleguide/go/index#about) для получения дополнительной информации.

## О статье

Этот документ содержит решения о стиле, предназначенные для единообразия и стандартизации руководства, объяснений и примеров для консультаций, предоставляемых разработчиками читаемости в Go.

Документ не является **исчерпывающим** и будет развиваться со временем. В случаях, когда [основное руководство по стилю](https://google.github.io/styleguide/go/guide) противоречит рекомендациям, предоставленным здесь, **стилевой руководник имеет приоритет**, и этот документ должен быть обновлен в соответствии с этим.

Пожалуйста, см. [Обзор](https://google.github.io/styleguide/go#about) для полного набора документов о стиле Go.

Следующие разделы были перенесены из решений о стиле в другую часть руководства:

* **Форматирование**: см. [руководство#форматирование](https://google.github.io/styleguide/go/guide#formatting)
* **MixedCaps**: см. [руководство#midxed-caps](https://google.github.io/styleguide/go/guide#mixed-caps)
* **Длина линии**: см. [руководство#длина-линии](https://google.github.io/styleguide/go/guide#line-length)

## Названия
Итак, существует несколько правил по именованию в языке Go. Внимание к разделу о наименованиях в рамках [руководства по стилю](https://google.github.io/styleguide/go/guide#naming) для получения общей информации о выборе подходящих имен. Далее в разделах даются более подробные пояснения по конкретным областям, связанным с именованием.

### Подчеркивания
В целом, имена в Go не должны содержать подчеркивания. Однако есть три исключения к этому правилу:

1. Имена пакетов, которые импортируются только сгенерированным кодом, могут содержать подчеркивания. Для получения дополнительной информации об выборе имен пакетов из нескольких слов, можно обратиться к [разделу о именах пакетов](https://google.github.io/styleguide/go/decisions#package-names).
2. Имена функций Test, Benchmark и Example в файлах *_test.go могут содержать подчеркивания.
3. Низкоуровневые библиотеки, взаимодействующие с операционной системой или cgo, могут повторно использовать идентификаторы, как это делается в пакете [`syscall`](https://pkg.go.dev/syscall#pkg-constants). Однако в большинстве кодовых баз такое использование подчеркиваний будет очень редким.

### Названия пакетов

Мы ожидаем, что имена пакетов в Go будут короткими и содержать только строчные буквы. Имя пакета, состоящее из нескольких слов, должно быть написано в нижнем регистре без пробелов или подчёркиваний. Например, пакет с именем [`tabwriter`](https://pkg.go.dev/text/tabwriter) должен называться именно так, а не `tabWriter`, `TabWriter` или `tab_writer`.

Старайся избегать выбора таких имен пакетов, которые могут быть [вытеснены](https://google.github.io/styleguide/go/best-practices#shadowing) обычно используемыми именами локальных переменных. Например, `usercount` - более подходящее имя пакета, чем `count`, так как `count` является общеиспользуемым именем переменной.

Имена пакетов в Go не должны содержать подчёркивания. Если тебе нужно импортировать пакет, имя которого содержит подчёркивание (обычно это происходит из сгенерированного или стороннего кода), то это имя должно быть переименовано при импорте в имя, подходящее для использования в коде на Go.

Одно исключение из этого правила – имена пакетов, которые импортируются только сгенерированным кодом, могут содержать подчёркивания. Конкретные примеры использования подчёркивания включают:

* Использование суффикса _test для внешнего тестового пакета, например, для интеграционного тестирования.
* Использование суффикса _test для примеров [документации на уровне пакета](https://go.dev/blog/examples).

Не рекомендуется использовать неинформативные имена пакетов, такие как `util`, `utility`, `common`, `helper` и так далее. Более подробно об этом можно прочитать в статье ["utility packages"](https://google.github.io/styleguide/go/best-practices#util-packages) на блоге Go.

Когда импортируемый пакет переименовывается (например, `import foopb "path/to/foo_go_proto"`), локальное имя для пакета должно соответствовать вышеуказанным правилам, так как это локальное имя определяет, как ссылаться на символы в пакете внутри файла. Если один и тот же импорт пакета переименовывается в нескольких файлах, особенно в одном или близлежащих пакетах, следует использовать одно и то же локальное имя для достижения согласованности.

А вот ссылка на замечательную [статью в блоге Go о наименованиях пакетов](https://go.dev/blog/package-names).

### Названия получателей

Имена [переменных-получателей](https://golang.org/ref/spec#Method_declarations) должны быть:

* Короткими (обычно длиной в одну или две буквы)
* Сокращеними для самого типа
* Применяться последовательно к каждому приемнику этого типа

| Длинное название  | Лучше назвать |
| ------------- | ------------- |
| `func (tray Tray)`  | `func (t Tray)`  |
| `func (info *ResearchInfo)`  | `func (ri *ResearchInfo)`  |
| `func (this *ReportWriter)`  | `func (w *ReportWriter)`  |
| `func (self *Scanner)`  | `func (s *Scanner)`  |

### Имена констант

Имена констант должны использовать [MixedCaps](https://google.github.io/styleguide/go/guide#mixed-caps), как и все другие имена в Go. ([Экспортируемые](https://tour.golang.org/basics/3) константы начинаются с заглавной буквы, а неэкспортируемые константы начинаются с маленькой буквы.) Это относится даже тогда, когда это нарушает соглашения в других языках. Имена констант не должны быть производными от их значений, а должны объяснять, что это значение обозначает.

```
// Хорошо:
const MaxPacketSize = 512

const (
    ExecuteBit = 1 << iota
    WriteBit
    ReadBit
)
```
Старайтесь не использовать имена констант без MixedCaps и константы с префиксом `K`.
```
// Плохо:
const MAX_PACKET_SIZE = 512
const kMaxBufferSize = 1024
const KMaxUsersPergroup = 500
```
Давайте именовать константы на основе их роли, а не их значений. Если константа не имеет роли помимо своего значения, то нет необходимости определять ее как константу.
```
// Bad:
const Twelve = 12

const (
    UserNameColumn = "username"
    GroupColumn    = "group"
)
```

### Аббревиатуры

Слова в именах, которые являются инициалами или акронимами (например, `URL` и `NATO`), должны быть написаны с использованием одинакового регистра. `URL` должно появляться как `URL` или `url` (как в `urlPony` или `URLPony`), но никогда не как `Url`. То же самое относится к `ID`, когда это сокращение от "identifier"; используйте `appID` вместо `appId`.

* В именах с несколькими аббревиатурами (например, `XMLAPI`, поскольку она содержит `XML` и `API`), каждая буква в данной аббревиатуре должна быть в одинаковом регистре, но каждый инициал в имени не обязательно должен иметь одинаковый регистр.
* В именах с аббревиатурой, содержащей строчную букву (например, `DDoS`, `iOS`, `gRPC`), аббревиатура должна появляться так же, как в стандартном тексте, за исключением того случая, когда вам нужно изменить первую букву в целях [экспортирования](https://golang.org/ref/spec#Exported_identifiers). В таких случаях вся аббревиатура должна иметь одинаковый регистр (например, `ddos`, `IOS`, `GRPC`).

| Аббревиатура | Доступность | Правильно | Неправильно |
| ------------- | ------------- | ------------- | ------------- |
| XML API | Exported | `XMLAPI` | `XmlApi`, `XMLApi`, `XmlAPI`, `XMLapi` |
| XML API | Unexported | `xmlAPI` | `xmlapi`, `xmlApi` |
| iOS | Exported | `IOS` | `Ios`, `IoS` |
| iOS | Unexported | `iOS` | `ios` |
| gRPC | Exported | `GRPC` | `Grpc` |
| gRPC | Unexported | `gRPC` | `grpc` |
| DDoS | Exported | `DDoS` | `DDOS`, `Ddos` |
| DDoS | Unexported | `ddos` | `dDoS`, `dDOS` |

### Геттеры

Названия функций и методов не должны использовать префикс `Get` или `get`, если базовая концепция не использует слово "get" (например, HTTP GET). Предпочтительнее начинать название прямо с существительного, например, использовать `Counts` вместо `GetCounts`.

Если функция включает выполнение сложных вычислений или вызов удаленного сервера, можно использовать другое слово, например `Compute` (вычисление) или `Fetch` (получение), чтобы ясно указать читателю, что вызов функции может занять время, блокироваться или завершиться неудачей.

### Названия переменных

Общее правило состоит в том, что длина имени должна быть пропорциональна размеру его области видимости и обратно пропорциональна количеству его использования в этой области. Переменная, созданная в глобальной области видимости файла, может требовать нескольких слов, тогда как переменная, ограниченная одним внутренним блоком, может быть как одним словом, так и несколькими символами, для того, чтобы код был чистым и не содержал лишней информации.

Вот грубый ориентир. Эти числовые рекомендации не являются строгими правилами. Применяйте суждение, основанное на контексте, [ясности](https://google.github.io/styleguide/go/guide#clarity) и [краткости](https://google.github.io/styleguide/go/guide#concision).

* Маленькая область - это область, в которой выполняется одна или две небольшие операции, скажем, 1-7 строк.
* Средняя область - это несколько небольших или одна большая операция, скажем, 8-15 строк.
* Большая область - это одна или несколько больших операций, скажем, от 15 до 25 строк.
* Очень большая область - это все, что простирается на несколько страниц (скажем, более 25 строк).

Имя, которое может быть полностью понятным (например, `c` для счетчика) внутри маленькой области, может оказаться недостаточным в большой области и потребовать пояснения, чтобы напомнить читателю его назначение в более поздних частях кода. Область, в которой существует много переменных или переменных, представляющих сходные значения или концепции, может потребовать более длинных имен переменных, чем область предполагает.

Специфичность концепции также может помочь в сохранении краткости имени переменной. Например, если предполагается, что используется только одна база данных, короткое имя переменной, такое как `db`, которое обычно зарезервировано для очень маленьких областей, может оставаться полностью понятным даже при очень большой области. В этом случае, единственное слово `database`, вероятно, будет приемлемо, основываясь на размере области, но не обязательно, поскольку `db` является очень распространенным сокращением для этого слова с немногими альтернативными интерпретациями.

Имя локальной переменной должно отражать то, что она содержит и как она используется в текущем контексте, а не откуда получено значение. Например, часто бывает так, что лучшее имя локальной переменной не совпадает с именем поля в структуре или протокольном буфере.

Резюмируя:

* Однословные имена, такие как `count` или `options`, являются хорошим началом.
* Дополнительные слова можно добавить для устранения неоднозначности схожих имен, например `userCount` и `projectCount`.
* Не сокращайте буквы просто, чтобы сэкономить время. Например, предпочтительнее использовать `Sandbox` вместо `Sbx`, особенно для экспортируемых имен.
* Оставляйте [типы и типо-подобные слова](https://google.github.io/styleguide/go/decisions#repetitive-with-type) в большинстве имен переменных.
  * Для чисел имя `userCount` лучше, чем `numUsers` или `usersInt`.
  * Для среза, имя `users` лучше, чем `userSlice`.
  * При необходимости можно добавить квалификатор типа, если в области видимости есть две версии значения, например, можно хранить входные данные в `ageString`, а использовать `age` для преобразованного значения.
* Пропускайте слова, ясные из [окружающего контекста](https://google.github.io/styleguide/go/decisions#repetitive-in-context). Например, при реализации метода `UserCount`, локальная переменная с именем `userCount`, вероятно, будет избыточной; `count`, `users` или даже `c` так же читаемы.

#### Однобуквенные названия переменных

Однобуквенные идентификаторы переменных могут быть полезными для минимизации [повторений](https://google.github.io/styleguide/go/decisions#repetition), но они также могут делать код более непонятным. Ограничьте их использование случаями, когда полное слово очевидно и когда его повторное использование было бы излишним.

Резюмируя:

* Для [переменной-получателя метода](https://google.github.io/styleguide/go/decisions#receiver-names) предпочтительно использовать однобуквенное или двухбуквенное имя.
* Использование знакомых идентификаторов переменных для общих типов часто полезно:
  * `r` для `io.Reader` или `*http.Request`
  * `w` для `io.Writer` или `http.ResponseWriter`
* Однобуквенные идентификаторы допустимы как целочисленные переменные для циклов, особенно для индексов (например, `i`) и координат (например, `x` и `y`).
* Аббревиатуры могут быть допустимыми идентификаторами циклов, когда область короткая, например, `for _, n := range nodes { ... }`.

### Повторение
Исходный код на Go должен избегать ненужного повторения. Одним из распространенных источников этого являются повторяющиеся имена, которые часто содержат лишние слова или повторяют свой контекст или тип. Сам код также может быть излишне повторяющимся, если один и тот же или похожий код появляется несколько раз в непосредственной близости.

Повторяющиеся имена могут принимать различные формы, включая:

#### Название пакета против названия экспортированного символа
При именовании экспортированных символов имя пакета всегда видимо за пределами вашего пакета, поэтому избыточную информацию между ними следует уменьшать или устранять. Если пакет экспортирует только один тип, и он назван в честь самого пакета, каноническое имя для конструктора - `New`, если он требуется.

> Примеры: Повторяющееся имя -> Лучшее имя
> 
> * widget.NewWidget -> widget.New
> * widget.NewWidgetWithName -> widget.NewWithName
> * db.LoadFromDatabase -> db.Load
> * goatteleportutil.CountGoatsTeleported -> gtutil.CountGoatsTeleported или goatteleport.Count
> * myteampb.MyTeamMethodRequest -> mtpb.MyTeamMethodRequest или myteampb.MethodRequest

#### Название переменной против типа

Компилятор всегда знает тип переменной, и в большинстве случаев для читателя также ясно, какой тип переменной по тому, как она используется. Необходимо уточнить тип переменной только в случае, если ее значение появляется дважды в одной и той же области видимости.

| Повторяющееся имя | Лучшее имя |
| ------------- | ------------- |
| `var numUsers int` |  `var users int` |
| `var nameString string` | `var name string` |
| `var primaryProject Project` | `var primary Project` |

Если значение появляется в нескольких формах, это можно пояснить либо с помощью дополнительного слова, например `raw` и `parsed`, либо с помощью базового представления:
```
// Хорошо:
limitStr := r.FormValue("limit")
limit, err := strconv.Atoi(limitStr)
```
```
// Хорошо:
limitRaw := r.FormValue("limit")
limit, err := strconv.Atoi(limitRaw)
```

#### Внешний контекст против локальных названий
Имена, которые включают информацию из окружающего контекста, часто создают дополнительный шум без пользы. Имя пакета, имя метода, имя типа, имя функции, путь импорта и даже имя файла могут предоставлять контекст, который автоматически квалифицирует все имена внутри.
```
// Плохо:
// В пакете "ads/targeting/revenue/reporting"
type AdsTargetingRevenueReport struct{}

func (p *Project) ProjectName() string
```
```
// Хорошо:
// В пакете "ads/targeting/revenue/reporting"
type Report struct{}

func (p *Project) Name() string
```
```
// Плохо:
// В пакете "sqldb"
type DBConnection struct{}
// Хорошо:
// В пакете "sqldb"
type Connection struct{}
```
```
// Плохо:
// В пакете "ads/targeting"
func Process(in pb.FooProto) Report {
    adsTargetingID := in.GetAdsTargetingID()
}
```
```
// Хорошо:
// В пакете "ads/targeting"
func Process(in pb.FooProto) Report {
    id := in.GetAdsTargetingID()
}
```
Повторение следует оценивать в контексте пользователей символа, а не в изоляции. Например, в следующем коде много имен, которые могут быть приемлемыми в некоторых случаях, но излишние в конкретном контексте:
```
// Плохо:
func (db *DB) UserCount() (userCount int, err error) {
    var userCountInt64 int64
    if dbLoadError := db.LoadFromDatabase("count(distinct users)", &userCountInt64); dbLoadError != nil {
        return 0, fmt.Errorf("failed to load user count: %s", dbLoadError)
    }
    userCount = int(userCountInt64)
    return userCount, nil
}
```
Вместо этого информацию о именах, которые явны из контекста или использования, можно часто опускать:
```
// Хорошо:
func (db *DB) UserCount() (int, error) {
    var count int64
    if err := db.Load("count(distinct users)", &count); err != nil {
        return 0, fmt.Errorf("failed to load user count: %s", err)
    }
    return int(count), nil
}
```

## Комментарии
Соглашения относительно комментирования (какие части кода комментировать, какой стиль использовать, как предоставлять запускаемые примеры и т. д.) предназначены для поддержки опыта чтения документации общедоступного API. Смотрите [Effective Go](http://golang.org/doc/effective_go.html#commentary) для получения дополнительной информации.

Лучшие практики документирования обсуждаются более подробно в главе [Правила документирования](https://google.github.io/styleguide/go/best-practices#documentation-conventions)

**Лучшая практика:** используйте [предварительный просмотр документации](https://google.github.io/styleguide/go/best-practices#documentation-preview) во время разработки и обзора кода, чтобы увидеть, полезны ли документация и запускаемые примеры, и представлены ли они так, как вы ожидаете.

**Совет:** Godoc использует очень незначительное форматирование; списки и фрагменты кода обычно следует делать с отступом, чтобы избежать переноса строк. За исключением отступов, обычно следует избегать оформления.

### Длина строки комментария
Обеспечьте возможность чтения комментариев из исходного кода даже на узких экранах.

Когда комментарий становится слишком длинным, рекомендуется разделить его на несколько однострочных комментариев. Старайтесь, по возможности, делать комментарии так, чтобы они хорошо читались на терминале шириной 80 символов, но это не жесткий предел; в Go нет фиксированного ограничения на длину строк комментариев. Например, стандартная библиотека часто разбивает комментарии на отдельные строки в зависимости от знаков препинания, что иногда приводит к длине строк около 60-70 символов.

Существует много существующего кода, в котором комментарии превышают 80 символов в длину. Однако этот факт не должен служить оправданием для изменения такого кода при анализе читаемости (см. [согласованность](https://google.github.io/styleguide/go/guide#consistency), хотя командам рекомендуется при возможности обновлять комментарии в соответствии с этим руководством в рамках других рефакторингов. Основная цель этого руководства - обеспечить, чтобы все руководители читабельности кода на Go давали одни и те же рекомендации при необходимости.

Пример хорошего комментария, который демонстрирует правильное форматирование:
```
// Это параграф комментария.
// Длина отдельных строк не имеет значения в Godoc;
// но выбор разделения делает его легко читаемым на узких экранах.
//
// Не беспокойтесь слишком сильно о длинном URL:
// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/
//
// Аналогично, если у вас есть другая информация, которая становится неудобной
// из-за слишком многих переносов строк, используйте свой суд и включите длинную строку,
// если это помогает, а не мешает.
```
Пример плохого комментария, который не следует рекомендациям форматирования:
```
// Это параграф комментария. Длина отдельных строк не имеет значения в
Godoc;
// но выбор разделения вызывает неровные строки на узких экранах или в рецензии
кода,
// что может быть раздражающим, особенно когда комментарий переносится
постоянно.
//
// Не беспокойтесь слишком сильно о длинном URL:
// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/
```

Важно следовать этим рекомендациям, чтобы сделать ваш код более читабельным и согласованным. Если вам интересно узнать больше о комментировании, рекомендуется прочитать [публикацию в блоге Go о документации](https://blog.golang.org/godoc-documenting-go-code).

### Комментарии к документации

Все имена верхнего уровня, экспортируемые из пакета, должны иметь документационные комментарии, также как и объявления неэкспортируемых типов или функций, имеющих неочевидное поведение или значение. Эти комментарии должны быть [полными предложениями](https://google.github.io/styleguide/go/decisions#comment-sentences), начинающимися с названия описываемого объекта. Можно использовать артикль ("a", "an", "the") перед названием для более естественного чтения.
```
// Хорошо:
// Request представляет запрос для выполнения команды.
type Request struct { ...

// Encode записывает JSON-кодировку req в w.
func Encode(w io.Writer, req *Request) { ...
```
Документационные комментарии отображаются в [Godoc](https://pkg.go.dev/) и доступны в интегрированных средах разработки, и поэтому они должны быть написаны для всех, кто использует пакет.

Документационный комментарий применяется к следующему символу или группе полей в случае структуры.
```
// Хорошо:
// Options настраивает службу управления группой.
type Options struct {
    // Общая настройка:
    Name  string
    Group *FooGroup

    // Зависимости:
    DB *sql.DB

    // Пользовательские настройки:
    LargeGroupThreshold int // опциональный, по умолчанию: 10
    MinimumMembers      int // опциональный, по умолчанию: 2
}
```
**Лучшая практика:** Если у вас есть документационные комментарии для неэкспортируемого кода, следуйте тому же шаблону, как если бы он был экспортируемым (в частности, начинайте комментарий с неэкспортируемого имени). Это позволит легко экспортировать его позднее, просто заменив неэкспортируемое имя на новое экспортируемое в комментариях и коде.

### Предложения в комментариях

Комментарии, которые представляют собой полные предложения, должны быть написаны с заглавной буквы и знаком препинания, как в обычном английском предложении. (Исключение составляют случаи, когда предложение начинается с идентификатора, написанного с маленькой буквы, если его значение явно и понятно. Такие случаи, вероятно, лучше употреблять только в начале абзацев.)

Комментарии, которые являются фрагментами предложений, не требуют пунктуации или написания с заглавной буквы.

[Комментарии к документации](https://google.github.io/styleguide/go/decisions#doc-comments) должны всегда представлять собой полные предложения и, следовательно, должны начинаться с заглавной буквы и иметь знаки препинания. Простые комментарии в конце строки (особенно для полей в структурах) могут быть простыми фразами, начиная с предположения, что имя поля является подлежащим.

```
// Good:
// A Server handles serving quotes from the collected works of Shakespeare.
type Server struct {
    // BaseDir points to the base directory under which Shakespeare's works are stored.
    //
    // The directory structure is expected to be the following:
    //   {BaseDir}/manifest.json
    //   {BaseDir}/{name}/{name}-part{number}.txt
    BaseDir string

    WelcomeMessage  string // отображается при входе пользователя
    ProtocolVersion string // проверяется при входящих запросах
    PageLength      int    // количество строк на странице при печати (опционально, по умолчанию: 20)
}
```

### Примеры

Пакеты должны четко документировать предполагаемое использование. Старайтесь предоставить [запускаемый пример](http://blog.golang.org/examples); примеры отображаются в Godoc. Запускаемые примеры должны находиться в тестовом файле, а не в файле исходного кода продукции. Смотрите этот пример ([Godoc](https://pkg.go.dev/time#example-Duration), [исходный код](https://cs.opensource.google/go/go/+/HEAD:src/time/example_test.go)).

Если невозможно предоставить запускаемый пример, код примера можно указать в комментариях к коду. Как и другие фрагменты кода и командной строки в комментариях, он должен соответствовать стандартным соглашениям форматирования.

### Именованные параметры результата

При именовании параметров результата следует учитывать, как функции отображаются в Godoc. Само имя функции и тип параметров результата часто достаточно понятны.
```
// Хорошо:
func (n Node) Parent1() Node
func (n Node) Parent2() (Node, error)
```
Если функция возвращает два или более параметра одного типа, их именование может быть полезным.
```
// Хорошо:
func (n Node) Children() (left, right Node, err error)
```
Если вызывающая сторона должна предпринять действия в отношении конкретных параметров результата, их именование может помочь указать, какие действия требуются:
```
// Хорошо:
// WithTimeout возвращает контекст, который будет отменен не позднее, чем через
// заданное время d от текущего момента.
//
// Вызывающая сторона должна убедиться, что возвращенная функция cancel будет
// вызвана, когда контекст больше не нужен, чтобы избежать утечки ресурсов.
func WithTimeout(parent Context, d time.Duration) (ctx Context, cancel func())
```
В приведенном выше коде отмена - это конкретное действие, которое должна предпринять вызывающая сторона. Однако, если бы параметры результата были записаны просто как `(Context, func())`, было бы неясно, что имеется в виду под "функцией отмены".

Не используйте именованные параметры результата, когда имена вызывают [лишнее повторение](https://google.github.io/styleguide/go/decisions#repetitive-with-type).
```
// Плохо:
func (n Node) Parent1() (node Node)
func (n Node) Parent2() (node Node, err error)
```
Не именуйте параметры результата, чтобы избежать объявления переменных внутри функции. Эта практика приводит к ненужной избыточности API за счет незначительного укорочения кода.

[Именованные возвращаемые значения](https://tour.golang.org/basics/7) допустимы только в небольших функциях. Как только функция становится среднего размера, следует явно указывать возвращаемые значения. Аналогично, не именуйте параметры результата просто потому, что это позволяет использовать именованные возвращаемые значения. [Ясность](https://google.github.io/styleguide/go/guide#clarity) всегда важнее, чем экономия нескольких строк в функции.

Всегда допустимо именовать параметр результата, если его значение должно быть изменено в отложенном (deferred) замыкании.

> **Совет:** Типы часто могут быть более понятными, чем имена в сигнатуре функции. [GoTip #38: "Функции как именованные типы"](https://google.github.io/styleguide/go/index.html#gotip) демонстрирует это.
> 
> Опираясь на пример выше с [`WithTimeout`](https://pkg.go.dev/context#WithTimeout), настоящий код использует [`CancelFunc`](https://pkg.go.dev/context#CancelFunc) вместо простого `func()` в списке параметров результата и не требует больших усилий для документирования.

### Комментарии к пакету

Комментарии к пакету должны быть непосредственно над предложением пакета без пустой строки между комментарием и именем пакета. Пример:
```
// Хорошо:
// Пакет math предоставляет основные константы и математические функции.
//
// Этот пакет не гарантирует одинаковые результаты между архитектурами.
package math
```
В пакете должен быть один комментарий к пакету на каждый пакет. Если пакет состоит из нескольких файлов, ровно один из файлов должен содержать комментарий к пакету.

Комментарии для пакетов `main` имеют немного другую форму, где имя правила `go_binary` в файле BUILD заменяет имя пакета.
```
// Хорошо:
// Команда seed_generator - это утилита, которая генерирует файл симуляции Finch
// из набора JSON-конфигураций исследования.
package main
```
Другие стили комментариев допустимы, если имя двоичного файла соответствует имени, указанному в файле BUILD. Когда имя двоичного файла является первым словом, его следует писать с заглавной буквы, даже если оно не соответствует строго написанию командной строки.
```
// Хорошо:
// Двоичный файл seed_generator ...
// Команда seed_generator ...
// Программа seed_generator ...
// Команда seed_generator ...
// Программа seed_generator ...
// Seed_generator ...
```
Советы:

* Примеры командной строки и использования API могут быть полезной документацией. Для форматирования в Godoc следует добавить отступы перед строками комментария, содержащими код.
* Если нет очевидного основного файла или если комментарий к пакету является чрезвычайно длинным, можно поместить комментарий в файл с именем `doc.go`, содержащим только комментарий и предложение пакета.
* Многострочные комментарии можно использовать вместо нескольких однострочных комментариев. Это особенно полезно, если документация содержит разделы, которые можно скопировать и вставить из исходного файла, например, с примерами командной строки (для двоичных файлов) и примерами шаблонов.
```
// Хорошо:
/*
Команда seed_generator - это утилита, которая генерирует файл симуляции Finch
из набора JSON-конфигураций исследования.

    seed_generator *.json | base64 > finch-seed.base64
*/
package template
```
* Комментарии, предназначенные для сопровождающих и применимые к всему файлу, обычно размещаются после импорта. Они не отображаются в Godoc и не подчиняются правилам, указанным выше для комментариев к пакету.

## Импорты

### Переименование инпортов

Импорты должны переименовываться только для избежания конфликта имён с другими импортами. (Как следствие этого, [хорошие имена пакетов](https://google.github.io/styleguide/go/decisions#package-names) не должны требовать переименования.) В случае конфликта имён предпочтительно переименовывать наиболее локальный или специфичный для проекта импорт. Локальные имена (псевдонимы) для пакетов должны следовать [рекомендациям по именованию пакетов](https://google.github.io/styleguide/go/decisions#package-names), включая запрет на использование подчеркиваний и заглавных букв.

Сгенерированные пакеты протоколов (protocol buffer packages) должны быть переименованы для удаления подчеркиваний из их имен, и их псевдонимы должны иметь суффикс `pb`. См. [рекомендации по протоколам и транспортам](https://google.github.io/styleguide/go/best-practices#import-protos) для получения дополнительной информации.
```
// Хорошо:
import (
    fspb "path/to/package/foo_service_go_proto"
)
```
Импорты, у которых имена пакетов не содержат полезной идентификационной информации (например, `package v1`), должны быть переименованы, чтобы включать предыдущий компонент пути. Переименование должно быть согласовано с другими локальными файлами, импортирующими тот же пакет, и может включать номер версии.

**Примечание:** Желательно переименовывать пакеты так, чтобы они соответствовали [хорошим именам пакетов](https://google.github.io/styleguide/go/decisions#package-names), но это часто неосуществимо для пакетов в каталогах продавцов.
```
// Хорошо:
import (
    core "github.com/kubernetes/api/core/v1"
    meta "github.com/kubernetes/apimachinery/pkg/apis/meta/v1beta1"
)
```

Если вам нужно импортировать пакет, имя которого совпадает с общим именем локальной переменной, которую вы хотите использовать (например, `url`, `ssh`) и вы хотите переименовать пакет, предпочтительный способ сделать это - это добавить суффикс `pkg` (например, `urlpkg`). Обратите внимание, что пакет можно замаскировать локальной переменной; переименование необходимо только в случае, если пакет все еще должен использоваться, когда такая переменная находится в области видимости.

### Группировка импортов
Импорты должны быть организованы в две группы:
* Пакеты стандартной библиотеки
* Другие (проектные и пакеты от поставщиков)
```
// Хорошо:
package main

import (
    "fmt"
    "hash/adler32"
    "os"

    "github.com/dsnet/compress/flate"
    "golang.org/x/text/encoding"
    "google.golang.org/protobuf/proto"
    foopb "myproj/foo/proto/proto"
    _ "myproj/rpc/protocols/dial"
    _ "myproj/security/auth/authhooks"
)
```

Допускается разделение проектных пакетов на несколько групп, например, если вы хотите отдельную группу для переименованных, импортированных только для побочных эффектов или еще какую-то особую группу импортов.
```
// Хорошо:
package main

import (
    "fmt"
    "hash/adler32"
    "os"

    "github.com/dsnet/compress/flate"
    "golang.org/x/text/encoding"
    "google.golang.org/protobuf/proto"

    foopb "myproj/foo/proto/proto"

    _ "myproj/rpc/protocols/dial"
    _ "myproj/security/auth/authhooks"
)
```

**Примечание:** Поддержка необязательных подгрупп, таких как стандартная библиотека и импорты Google - не поддерживается инструментом [goimports](https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports). Дополнительные подгруппы импортов требуют внимания со стороны авторов и рецензентов для поддержания соответствующего состояния.

Программы Google, которые также являются приложениями AppEngine, должны иметь отдельную группу для импортов AppEngine.

Gofmt заботится о сортировке каждой группы по пути импорта. Однако он не разделяет импорты автоматически на группы. Популярный инструмент [goimports](https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports) объединяет Gofmt и управление импортами, разделяя импорты на группы на основе принятого решения. Допускается полностью доверить [goimports](https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports) управление порядком импортов, так что даже при изменении файла, его список импортов будет оставаться внутренне согласованным.

### Импорт "пустого" пакета (`import _`)

Пакеты, которые импортируются только для своих побочных эффектов (используя синтаксис `import _ "package"`), могут быть импортированы только в главный пакет или в тесты, которым они нужны.

Некоторые примеры таких пакетов включают:
* [time/tzdata](https://pkg.go.dev/time/tzdata)
* [image/jpeg](https://pkg.go.dev/image/jpeg) в коде обработки изображений

Избегайте пустых импортов в библиотечных пакетах, даже если библиотека зависит от них косвенно. Ограничение импортов с побочными эффектами до главного пакета помогает контролировать зависимости и позволяет писать тесты, основанные на другом импорте, без конфликтов или излишних затрат на сборку.

Следующий список является единственным исключением из этого правила:
* Вы можете использовать пустой импорт для обхода проверки на запрещенные импорты в [статическом анализаторе nogo](https://github.com/bazelbuild/rules_go/blob/master/go/nogo.rst).
* Вы можете использовать пустой импорт пакета [embed](https://pkg.go.dev/embed) в исходном файле, который использует компиляторную директиву `//go:embed`.

**Совет:** Если вы создаете библиотечный пакет, который косвенно зависит от импорта с побочными эффектами в продакшене, задокументируйте предполагаемое использование.

### Импорт "точка" (`import .`)

Форма `import .` - это возможность языка, позволяющая привносить идентификаторы, экспортируемые из другого пакета, в текущий пакет без квалификации. Дополнительную информацию см. в [спецификации языка](https://go.dev/ref/spec#Import_declarations).

**Не** используйте эту функцию в кодовой базе Google; это затрудняет определение, откуда идет функциональность.
```
// Плохо:
package foo_test

import (
    "bar/testutil" // также импортирует "foo"
    . "foo"
)

var myThing = Bar() // Bar определен в пакете foo; не требуется квалификация.
```
```
// Хорошо:
package foo_test

import (
    "bar/testutil" // также импортирует "foo"
    "foo"
)

var myThing = foo.Bar()
```

## Ошибки

### Возвращаемые ошибки

Используйте тип `error`, чтобы указать на возможность сбоя функции. Согласно соглашению, тип `error` должен быть последним параметром результата функции.
```
// Хорошо:
func Good() error { /* ... */ }
```

Возвращение `nil` в качестве ошибки является принятой практикой для сигнализации об успешной операции, которая может потенциально завершиться с ошибкой. Если функция возвращает ошибку, вызывающий код должен рассматривать все значения, возвращаемые функцией, кроме ошибки, как неопределенные, если явно не указано обратное в документации. Обычно значения, не являющиеся ошибкой, равны нулевым значениям своих типов, но на это нельзя полагаться.
```
// Хорошо:
func GoodLookup() (*Result, error) {
    // ...
    if err != nil {
        return nil, err
    }
    return res, nil
}
```

Экспортируемые функции, возвращающие ошибки, должны возвращать их с использованием типа `error`. Конкретные типы ошибок могут быть подвержены тонким ошибкам: конкретный указатель `nil` может быть обернут в интерфейс и, таким образом, стать ненулевым значением (см. раздел [FAQ по этой теме в документации Go](https://golang.org/doc/faq#nil_error)).
```
// Плохо:
func Bad() *os.PathError { /* ... */ }
```

**Совет:** Функция, принимающая аргумент `context.Context`, обычно должна возвращать ошибку, чтобы вызывающий код мог определить, был ли контекст отменен во время выполнения функции.

### Строковые ошибки

Строковые ошибки не должны быть написаны с заглавной буквы (за исключением случаев, когда они начинаются с экспортированного имени, собственного имени или аббревиатуры) и не должны заканчиваться знаками препинания. Это связано с тем, что строковые ошибки обычно появляются в контексте других сообщений до вывода пользователю.
```
// Плохо:
err := fmt.Errorf("Something bad happened.")
```
```
// Хорошо:
err := fmt.Errorf("something bad happened")
```

С другой стороны, стиль полного отображаемого сообщения (логирование, сообщение об ошибке в тесте, ответ от API или другой пользовательский интерфейс) может отличаться, но обычно должен быть написан с заглавной буквы.
```
// Хорошо:
log.Infof("Operation aborted: %v", err)
log.Errorf("Operation aborted: %v", err)
t.Errorf("Op(%q) failed unexpectedly; err=%v", args, err)
```

### Обработка ошибок

Код, который обнаруживает ошибку, должен принять осознанное решение о способе ее обработки. Обычно неправильно игнорировать ошибки с использованием `_` переменных. Если функция возвращает ошибку, выполните одно из следующих действий:

* Сразу обработайте и решите проблему с ошибкой.
* Верните ошибку вызывающему коду.
* В исключительных ситуациях можно вызвать [`log.Fatal`](https://pkg.go.dev/github.com/golang/glog#Fatal) или (если строго необходимо) `panic`.

**Примечание:** `log.Fatalf` не является частью стандартной библиотеки log. См. раздел [Логирование](https://google.github.io/styleguide/go/decisions#logging).

В редких случаях, когда допустимо игнорировать или отбросить ошибку (например, при вызове записи (*bytes.Buffer).Write, который по документации никогда не вызывает ошибку), сопровождающий комментарий должен объяснить причины безопасности такого действия.
```
// Хорошо:
var b *bytes.Buffer

n, _ := b.Write(p) // никогда не возвращает ошибку, которая не равна nil
```

Для более обширного обсуждения и примеров обработки ошибок смотрите [Effective Go](http://golang.org/doc/effective_go.html#errors) и [лучшие практики](https://google.github.io/styleguide/go/best-practices.html#error-handling).

### Встроенные ошибки (In-band)

В языке С и аналогичных языках часто функции возвращают значения, такие как -1, null или пустую строку, чтобы сигнализировать об ошибках или отсутствии результатов. Это называется обработкой ошибок внутри диапазона значений.
```
// Плохо:
// Lookup возвращает значение для ключа или -1, если нет соответствия для ключа.
func Lookup(key string) int
```

Отзказ от проверки возвращаемого значения ошибки внутри диапазона значений может привести к неправильному присвоению ошибок функции.
```
// Плохо:
// Следующая строка возвращает ошибку о том, что разбор не удался для входного значения,
// хотя ошибка заключается в том, что нет соответствия для missingKey.
return Parse(Lookup(missingKey))
```

Более хорошим решением является использование возможности Go для возвращения нескольких значений (см. раздел [Effective Go о множественных возвращаемых значениях](http://golang.org/doc/effective_go.html#multiple-returns)). Вместо того, чтобы требовать от клиентского кода проверять возвращаемое значение ошибки внутри диапазона значений, функция должна возвращать дополнительное значение, указывающее, являются ли ее другие возвращаемые значения действительными. Это может быть значение типа error или булево значение, когда не требуется дополнительное пояснение, и должно быть последним возвращаемым значением.
```
// Хорошо:
// Lookup возвращает значение для ключа или ok=false, если нет соответствия для ключа.
func Lookup(key string) (value string, ok bool)
```

Такой интерфейс предотвращает неправильное написание `Parse(Lookup(key))`, что приводит к ошибке во время компиляции, поскольку `Lookup(key)` имеет 2 выходных значения.

Возврат ошибок таким образом поощряет более надежную и явную обработку ошибок:
```
// Хорошо:
value, ok := Lookup(key)
if !ok {
    return fmt.Errorf("no value for %q", key)
}
return Parse(value)
```

Некоторые функции стандартной библиотеки, такие как те в пакете `strings`, возвращают ошибки внутри диапазона значений. Это значительно упрощает код для работы со строками, но требует большей внимательности от программиста. В целом код на Go в кодовой базе Google должен возвращать дополнительные значения для ошибок.

### Идентичная обработка ошибок

Обработайте ошибки перед продолжением выполнения остального кода. Это улучшает читаемость кода, позволяя читателю быстро перейти к нормальному пути выполнения. Та же логика применима к любому блоку, который проверяет условие, а затем заканчивается завершающим условием (например, `return`, `panic`, `log.Fatal`).

Код, который выполняется, если завершающее условие не выполняется, должен находиться после блока `if`, и не должен быть вложен в блок `else`.
```
// Хорошо:
if err != nil {
    // обработка ошибки
    return // или continue и т.д.
}
// нормальный код
```
```
// Плохо:
if err != nil {
    // обработка ошибки
} else {
    // нормальный код, который выглядит необычно из-за отступов
}
```

> **Совет:** Если вы используете переменную на протяжении нескольких строк кода, то обычно нет смысла использовать стиль if с инициализатором. В таких случаях лучше поместите объявление переменной вне блока и используйте стандартный оператор if:
>```
> // Хорошо:
> x, err := f()
> if err != nil {
>   // обработка ошибки
>   return
> }
> // множество кода, использующего x
> // на протяжении нескольких строк
>```
>```
> // Плохо:
> if x, err := f(); err != nil {
>  // обработка ошибки
>  return
>} else {
>  // множество кода, использующего x
>  // на протяжении нескольких строк
>}
>```


Для получения дополнительных деталей смотрите ["Совет по Go #1: Линия прямой видимости"](https://google.github.io/styleguide/go/index.html#gotip) и ["TotT: Уменьшите сложность кода за счет уменьшения вложенности"](https://testing.googleblog.com/2017/06/code-health-reduce-nesting-reduce.html).

## Язык

### Форматирование литералов
В Go существует очень мощный [синтаксис составных литералов](https://golang.org/ref/spec#Composite_literals), с помощью которого можно выразить сложные вложенные значения в одном выражении. По возможности следует использовать этот синтаксис литералов вместо построения значений поле за полем. Обычно `gofmt` форматирует литералы достаточно хорошо, но есть некоторые дополнительные правила для поддержания читабельности и поддерживаемости этих литералов.

#### Имена полей
Структурные литералы обычно должны указывать **имена полей** для типов, определенных вне текущего пакета.

* Включите имена полей для типов из других пакетов.
    ```
    // Хорошо:
    good := otherpkg.Type{A: 42}
    ```

    Положение полей в структуре и полный набор полей (которые являются необходимыми при опущенных именах полей) обычно не считаются частью публичного API структуры. Указание имени поля необходимо, чтобы избежать ненужной связанности.
    ```
    // Плохо:
    // https://pkg.go.dev/encoding/csv#Reader
    r := csv.Reader{',', '#', 4, false, false, false, false}
    ```

    Имена полей могут быть опущены при маленьких и простых структурах, чье составление и порядок документируются как стабильные.
    ```
    // Хорошо:
    okay := image.Point{42, 54}
    also := image.Point{X: 42, Y: 54}
    ```

* Для типов из текущего пакета имена полей являются опциональными.
    ```
    // Хорошо:
    okay := Type{42}
    also := internalType{4, 2}
    ```
    
    Имена полей следует использовать, если они делают код более понятным, и это очень распространено. Например, структура с большим количеством полей практически всегда должна инициализироваться с использованием имен полей.
    ```
    // Хорошо:
    okay := StructWithLotsOfFields{
      field1: 1,
      field2: "two",
      field3: 3.14,
      field4: true,
    }
    ```

#### Согласование фигурных скобок

Закрывающая половина пары фигурных скобок должна всегда находиться на той же строке с таким же отступом, что и открывающая фигурная скобка. У однострочных литералов это свойство выполняется автоматически. Когда литерал занимает несколько строк, поддержание этого свойства сохраняет согласованность фигурных скобок для литералов такой же, как для обычных конструкций на Go, таких как функции и условия `if`.

Наиболее распространенной ошибкой в этой области является помещение закрывающей скобки на ту же строку, что и значение в многострочном структурном литерале. В таких случаях строка должна заканчиваться запятой, и закрывающая скобка должна появиться на следующей строке.
```
// Хорошо:
good := []*Type{{Key: "value"}}
```
```
// Хорошо:
good := []*Type{
    {Key: "multi"},
    {Key: "line"},
}
```
```
// Плохо:
bad := []*Type{
    {Key: "multi"},
    {Key: "line"}}
```
```
// Плохо:
bad := []*Type{
    {
        Key: "value"},
}
```

#### Объятия фигурных скобок
Отбрасывание пробелов между фигурными скобками (их "Объятие") для литералов срезов и массивов разрешено только в том случае, если справедливы оба следующих условия:

* [Отступ совпадает](https://google.github.io/styleguide/go/decisions#literal-matching-braces).
* Внутренние значения также являются литералами или построителями протокола (то есть не являются переменными или другими выражениями).
```
// Хорошо:
good := []*Type{
    { // Не объято
        Field: "value",
    },
    {
        Field: "value",
    },
}
```
```
// Хорошо:
good := []*Type{{ // Объятие выполнено правильно
    Field: "value",
}, {
    Field: "value",
}}
```
```
// Хорошо:
good := []*Type{
    first, // Не может быть объято
    {Field: "second"},
}
```
```
// Хорошо:
okay := []*pb.Type{pb.Type_builder{
    Field: "first", // Построители протокола могут быть объяты, чтобы сохранить вертикальное пространство
}.Build(), pb.Type_builder{
    Field: "second",
}.Build()}
```
```
// Плохо:
bad := []*Type{
    first,
    {
        Field: "second",
    }}
```

#### Повторяющиеся имена типов
Повторяющиеся имена типов могут быть опущены в литералах срезов и карт. Это может помочь уменьшить перемешивание. Разумным моментом для явного повторения имен типов является работа с сложными типами, которые не так часто встречаются в вашем проекте, когда повторяющиеся имена типов находятся на далеко разнесенных строках и могут напомнить читателю о контексте.
```
// Хорошо:
good := []*Type{
    {A: 42},
    {A: 43},
}
```
```
// Плохо:
repetitive := []*Type{
    &Type{A: 42},
    &Type{A: 43},
}
```
```
// Хорошо:
good := map[Type1]*Type2{
    {A: 1}: {B: 2},
    {A: 3}: {B: 4},
}
```
```
// Плохо:
repetitive := map[Type1]*Type2{
    Type1{A: 1}: &Type2{B: 2},
    Type1{A: 3}: &Type2{B: 4},
}
```

**Совет:** Если вы хотите убрать повторяющиеся имена типов в литералах структур, вы можете использовать команду `gofmt -s`.

#### Поля с нулевыми значениями
[Поля с нулевыми значениями](https://golang.org/ref/spec#The_zero_value) могут быть опущены при создании литералов структур, если это не влияет на ясность кода.

Хорошо разработанные API часто используют конструирование с нулевыми значениями для улучшения читабельности кода. Например, опуская три поля со значением ноль в следующей структуре, обращается внимание только на определенный параметр.
```
// Плохо:
import (
  "github.com/golang/leveldb"
  "github.com/golang/leveldb/db"
)

ldb := leveldb.Open("/my/table", &db.Options{
    BlockSize: 1<<16,
    ErrorIfDBExists: true,

    // Все эти поля имеют значения по умолчанию.
    BlockRestartInterval: 0,
    Comparer: nil,
    Compression: nil,
    FileSystem: nil,
    FilterPolicy: nil,
    MaxOpenFiles: 0,
    WriteBufferSize: 0,
    VerifyChecksums: false,
})
```
```
// Хорошо:
import (
  "github.com/golang/leveldb"
  "github.com/golang/leveldb/db"
)

ldb := leveldb.Open("/my/table", &db.Options{
    BlockSize: 1<<16,
    ErrorIfDBExists: true,
})
```

Структуры в таблице-проводнике тестов часто выгодно использовать [явные имена полей](https://google.github.io/styleguide/go/decisions#literal-field-names), особенно когда структура теста не является тривиальной. Это позволяет автору полностью опустить поля с нулевыми значениями, когда эти поля не относятся к конкретному тестовому случаю. Например, успешные тестовые случаи должны опускать все поля, связанные с ошибками или сбоями. В случаях, когда нулевое значение необходимо для понимания тестового случая, например, для тестирования нулевого или `nil` ввода, следует указывать имена полей.

**Краткий способ**
```
tests := []struct {
    input      string
    wantPieces []string
    wantErr    error
}{
    {
        input:      "1.2.3.4",
        wantPieces: []string{"1", "2", "3", "4"},
    },
    {
        input:   "hostname",
        wantErr: ErrBadHostname,
    },
}
```

**Явный способ**
```
tests := []struct {
    input    string
    wantIPv4 bool
    wantIPv6 bool
    wantErr  bool
}{
    {
        input:    "1.2.3.4",
        wantIPv4: true,
        wantIPv6: false,
    },
    {
        input:    "1:2::3:4",
        wantIPv4: false,
        wantIPv6: true,
    },
    {
        input:    "hostname",
        wantIPv4: false,
        wantIPv6: false,
        wantErr:  true,
    },
}
```

### Нуллевые срезы (Nil slices)
В большинстве случаев между `nil` и пустым срезом нет функциональной разницы. Встроенные функции, такие как `len` и `cap`, ведут себя ожидаемым образом с нулевыми срезами.
```
// Хорошо:
import "fmt"

var s []int         // nil

fmt.Println(s)      // []
fmt.Println(len(s)) // 0
fmt.Println(cap(s)) // 0
for range s {...}   // no-op

s = append(s, 42)
fmt.Println(s)      // [42]
```

Если вы объявляете пустой срез в качестве локальной переменной (особенно если он может быть возвращаемым значением), предпочтительнее использовать инициализацию с `nil`, чтобы уменьшить риск возникновения ошибок у вызывающего кода.
```
// Хорошо:
var t []string
```
```
// Плохо:
t := []string{}
```

Не создавайте такие API, которые заставляют клиентов делать различие между `nil` и пустым срезом.

```
// Хорошо:
// Ping пингует указанные цели.
// Возвращает хосты, успешно ответившие.
func Ping(hosts []string) ([]string, error) { ... }
```
```
// Плохо:
// Ping пингует указанные цели и возвращает список хостов,
// успешно ответивших. Может быть пустым, если входной срез пуст.
// nil указывает на то, что произошла системная ошибка.
func Ping(hosts []string) []string { ... }
```

При проектировании интерфейсов старайтесь не делать различий между `nil`-срезом и пустым срезом, так как это может привести к тонким ошибкам программирования. Обычно это достигается с помощью оператора `len` для проверки пустоты, а не сравнения с `nil`.

В этой реализации как `nil`, так и срез нулевой длины принимаются как «пустые»:
```
// Хорошо:
// describeInts описывает s с заданным префиксом, если s не пустой.
func describeInts(prefix string, s []int) {
    if len(s) == 0 {
        return
    }
    fmt.Println(prefix, s)
}
```

Вместо полаганияс различие становится частью API:
```
// Плохо:
func maybeInts() []int { /* ... */ }

// describeInts описывает s с заданным префиксом; передайте nil, чтобы полностью пропустить.
func describeInts(prefix string, s []int) {
  // Поведение этой функции намеренно меняется в зависимости от того, что
  // maybeInts() возвращает в 'пустых' случаях (nil или []int{}).
  if s == nil {
    return
  }
  fmt.Println(prefix, s)
}

describeInts("Вот некоторые целые числа:", maybeInts())
```
Смотрите также [Встроенные ошибки](https://google.github.io/styleguide/go/decisions#in-band-errors) для дальнейшего обсуждения.

### Ошибки при форматировании отступов
Избегайте ввода переноса строки, если это выравнивает остаток строки с блоком кода, имеющим отступ. Если такое совпадение невозможно, оставьте пробел для разделения кода в блоке от перенесенной строки.
```
// Плохо:
if longCondition1 && longCondition2 &&
    // Условия 3 и 4 имеют такой же отступ, как код внутри if.
    longCondition3 && longCondition4 {
    log.Info("выполнены все условия")
}
```

См. следующие разделы для конкретных рекомендаций и примеров:

* [Форматирование функций](https://google.github.io/styleguide/go/decisions#func-formatting)
* [Условные выражения и циклы](https://google.github.io/styleguide/go/decisions#conditional-formatting)
* [Форматирование литералов](https://google.github.io/styleguide/go/decisions#literal-formatting)

### Форматирование функций
В объявлении функции или метода сигнатура должна оставаться на одной строке, чтобы избежать [путаницы с отступами](https://google.github.io/styleguide/go/decisions#indentation-confusion).

Списки аргументов функций могут занимать самые длинные строки в исходном файле на Go. Однако они предшествуют изменению отступа, поэтому трудно разбить строку таким образом, чтобы остальные строки не выглядели как часть тела функции в непонятном виде:
```
// Плохо:
func (r *SomeType) SomeLongFunctionName(foo1, foo2, foo3 string,
    foo4, foo5, foo6 int) {
    foo7 := bar(foo1)
    // ...
}
```

См. [лучшие практики](https://google.github.io/styleguide/go/best-practices#funcargs), чтобы узнать о нескольких вариантах сокращения вызовов функций, которые в противном случае имели бы много аргументов.
```
// Хорошо:
good := foo.Call(long, CallOptions{
    Names:   list,
    Of:      of,
    The:     parameters,
    Func:    all,
    Args:    on,
    Now:     separate,
    Visible: lines,
})
```
```
// Плохо:
bad := foo.Call(
    long,
    list,
    of,
    parameters,
    all,
    on,
    separate,
    lines,
)
```

Строки часто можно сократить путем выноса локальных переменных.
```
// Хорошо:
local := helper(some, parameters, here)
good := foo.Call(list, of, parameters, local)
```

Аналогично, вызовы функций и методов не должны разделяться исключительно на основе длины строки.
```
// Хорошо:
good := foo.Call(long, list, of, parameters, all, on, one, line)
```
```
// Плохо:
bad := foo.Call(long, list, of, parameters,
    with, arbitrary, line, breaks)
```


Не добавляйте комментарии к конкретным параметрам функции. Вместо этого используйте [структуру параметров](https://google.github.io/styleguide/go/best-practices#option-structure) или добавьте более подробную информацию в документацию функции.
```
// Хорошо:
good := server.New(ctx, server.Options{Port: 42})
```
```
// Плохо:
bad := server.New(
    ctx,
    42, // Порт
)
```


Если вызовы являются неудобно длинными, рассмотрите возможность рефакторинга.
```
// Хорошо:
// Иногда вариативные аргументы могут быть вынесены
replacements := []string{
    "из", "в", // связанные значения могут быть отформатированы рядом друг с другом
    "исходный", "исправленный",
}

// Используйте структуру replacements в качестве входных данных для NewReplacer.
replacer := strings.NewReplacer(replacements...)
```

Если API невозможно изменить или если локальный вызов необычен (независимо от того, является ли вызов слишком длинным), всегда допустимо добавлять переносы строк, если это помогает понять вызов.

```
// Хорошо:
canvas.RenderCube(cube,
    x0, y0, z0,
    x0, y0, z1,
    x0, y1, z0,
    x0, y1, z1,
    x1, y0, z0,
    x1, y0, z1,
    x1, y1, z0,
    x1, y1, z1,
)
```

Обратите внимание, что строки в приведенном выше примере не переносятся на определенном столбце, а группируются на основе троек координат.

Длинные строковые литералы внутри функций не должны разбиваться из-за длины строки. Для функций, которые содержат такие строки, после форматирования строки можно добавить перенос строки, а аргументы можно указать на следующих или последующих строках. Решение о том, где должны быть разделены строки, лучше принимать на основе семантической группировки входных данных, а не только на основе длины строки.
```
// Хорошо:
log.Warningf("Database key (%q, %d, %q) incompatible in transaction started by (%q, %d, %q)",
    currentCustomer, currentOffset, currentKey,
    txCustomer, txOffset, txKey)
```
```
// Плохо:
log.Warningf("Database key (%q, %d, %q) incompatible in"+
    " transaction started by (%q, %d, %q)",
    currentCustomer, currentOffset, currentKey, txCustomer,
    txOffset, txKey)
```

### Условные операторы и циклы
Оператор `if` не должен разбиваться на несколько строк; многострочные условия `if` могут вызывать [путаницу в отступах](https://google.github.io/styleguide/go/decisions#indentation-confusion).
```
// Плохо:
// Второй оператор if выровнен с кодом внутри блока if, вызывая путаницу в отступах.
if db.CurrentStatusIs(db.InTransaction) &&
    db.ValuesEqual(db.TransactionKey(), row.Key()) {
    return db.Errorf(db.TransactionError, "query failed: row (%v): key does not match transaction key", row)
}
```

Если короткозамыкающее поведение не требуется, булевские операнды могут быть извлечены напрямую:
```
// Хорошо:
inTransaction := db.CurrentStatusIs(db.InTransaction)
keysMatch := db.ValuesEqual(db.TransactionKey(), row.Key())
if inTransaction && keysMatch {
    return db.Error(db.TransactionError, "query failed: row (%v): key does not match transaction key", row)
}
```
Также могут быть другие локальные переменные, особенно если условие уже повторяется:
```
// Хорошо:
uid := user.GetUniqueUserID()
if db.UserIsAdmin(uid) db.UserHasPermission(uid, perms.ViewServerConfig) db.UserHasPermission(uid, perms.CreateGroup) {
    // ...
}
```
```
// Плохо:
if db.UserIsAdmin(user.GetUniqueUserID()) db.UserHasPermission(user.GetUniqueUserID(), perms.ViewServerConfig) db.UserHasPermission(user.GetUniqueUserID(), perms.CreateGroup) {
    // ...
}
```

Операторы `if`, содержащие замыкания или многострочные литералы структур, должны проверять, чтобы [фигурные скобки соответствовали друг другу](https://google.github.io/styleguide/go/decisions#literal-matching-braces), чтобы избежать [путаницы в отступах](https://google.github.io/styleguide/go/decisions#indentation-confusion).

```
// Хорошо:
if err := db.RunInTransaction(func(tx *db.TX) error {
    return tx.Execute(userUpdate, x, y, z)
}); err != nil {
    return fmt.Errorf("user update failed: %s", err)
}
```
```
// Хорошо:
if _, err := client.Update(ctx, &upb.UserUpdateRequest{
    ID:   userID,
    User: user,
}); err != nil {
    return fmt.Errorf("user update failed: %s", err)
}
```

Также не пытайтесь вставлять искусственные переносы строк в операторы `for`. Всегда можно просто оставить строку длинной, если нет элегантного способа перестроить ее:
```
// Хорошо:
for i, max := 0, collection.Size(); i < max && !collection.HasPendingWriters(); i++ {
    // ...
}
```
Однако часто появляется:
```
// Хорошо:
for i, max := 0, collection.Size(); i < max; i++ {
    if collection.HasPendingWriters() {
        break
    }
    // ...
}
```
Операторы `switch` и `case` также должны быть находиться в одной строке.
```
// Хорошо:
switch good := db.TransactionStatus(); good {
case db.TransactionStarting, db.TransactionActive, db.TransactionWaiting:
    // ...
case db.TransactionCommitted, db.NoTransaction:
    // ...
default:
    // ...
}
```
```
// Плохо:
switch bad := db.TransactionStatus(); bad {
case db.TransactionStarting,
    db.TransactionActive,
    db.TransactionWaiting:
    // ...
case db.TransactionCommitted,
    db.NoTransaction:
    // ...
default:
    // ...
}
```
Если строка чрезмерно длинная, отступите все случаи и отделите их пустой строкой, чтобы избежать [путаницы в отступах](https://google.github.io/styleguide/go/decisions#indentation-confusion):
```
// Хорошо:
switch db.TransactionStatus() {
case
    db.TransactionStarting,
    db.TransactionActive,
    db.TransactionWaiting,
    db.TransactionCommitted:

    // ...
case db.NoTransaction:
    // ...
default:
    // ...
}
```
В условных операторах, сравнивающих переменную с константой, помещайте значение переменной слева от оператора равенства:
```
// Хорошо:
if result == "foo" {
  // ...
}
```
Вместо менее понятного фразирования, где константа идет первой (["условия в стиле Йоды"](https://en.wikipedia.org/wiki/Yoda_conditions)):
```
// Плохо:
if "foo" == result {
  // ...
}
```

### Копирование

Чтобы избежать неожиданного копирования и подобных ошибок, будьте осторожны при копировании структуры из другого пакета. Например, объекты синхронизации, такие как `sync.Mutex`, не должны копироваться.

Тип `bytes.Buffer` содержит срез `[]byte` и, для оптимизации работы со строками малого размера, небольшой байтовый массив, на который может ссылаться срез. Если вы копируете `Buffer`, срез в копии может ссылаться на массив в оригинале, что может приводить к неожиданным эффектам при вызове методов.

Вообще говоря, не копируйте значение типа `T`, если его методы ассоциированы с типом указателя `*T`.
```
// Плохо:
b1 := bytes.Buffer{}
b2 := b1
```
Вызов метода, который принимает значение в качестве получателя, может скрыть копию. Когда вы разрабатываете API, вы обычно должны использовать указатели в качестве параметров и возвращаемых значений, если ваши структуры содержат поля, которые не должны копироваться.

Это примеры приемлемого использования:
```
// Хорошо:
type Record struct {
  buf bytes.Buffer
  // другие поля опущены
}

func New() *Record {...}

func (r *Record) Process(...) {...}

func Consumer(r *Record) {...}
```
Но следующее обычно неправильно:
```
// Плохо:
type Record struct {
  buf bytes.Buffer
  // другие поля опущены
}

func (r Record) Process(...) {...} // Создает копию r.buf

func Consumer(r Record) {...} // Создает копию r.buf
```
Эти рекомендации также относятся к копированию `sync.Mutex`.


### Не паникуйте

Не используйте `panic` для обработки нормальных ошибок. Вместо этого используйте `error` и множественные возвращаемые значения. См. раздел [Effective Go об ошибках](http://golang.org/doc/effective_go.html#errors).

В коде пакета `main` и коде инициализации рассмотрите использование [`log.Exit`](https://pkg.go.dev/github.com/golang/glog#Exit) для ошибок, которые должны привести к завершению программы (например, некорректная конфигурация), так как в таких случаях трассировка стека не поможет разработчику. Обратите внимание, что [`log.Exit`](https://pkg.go.dev/github.com/golang/glog#Exit) вызывает [`os.Exit`](https://pkg.go.dev/os#Exit), и отложенные функции не будут выполнены.

Для ошибок, которые указывают на "невозможные" условия, то есть на ошибки, которые всегда должны быть обнаружены при рассмотрении кода и/или тестировании, функция может разумно возвращать ошибку или вызывать [`log.Fatal`](https://pkg.go.dev/github.com/golang/glog#Fatal).

**Примечание:** `log.Fatalf` не является частью стандартной библиотеки `log`. См. раздел [Логирование](https://google.github.io/styleguide/go/decisions#logging).

### Обязательные функции
Вспомогательные функции настройки, которые останавливают программу в случае ошибки, следуют соглашению об именовании `MustXYZ` (или `mustXYZ`). В целом, их следует вызывать только в самом начале запуска программы, а не в случае, например, пользовательского ввода, где предпочтительна обычная обработка ошибок Go.

Это часто применяется для функций, вызываемых для инициализации переменных на уровне пакета исключительно во время инициализации пакета (например, `template.Must` и `regexp.MustCompile`).
```
// Хорошо:
func MustParse(version string) *Version {
    v, err := Parse(version)
    if err != nil {
        log.Fatalf("MustParse(%q) = _, %v", version, err)
    }
    return v
}

// "Константа" на уровне пакета. Если мы хотели использовать Parse, мы должны были бы установить значение в init.
var DefaultVersion = MustParse("1.2.3")
```
**Примечание:** `log.Fatalf` не является частью стандартной библиотеки `log`. См. раздел [Логирование](https://google.github.io/styleguide/go/decisions#logging).

То же самое соглашение может использоваться в тестовых утилитах, которые просто останавливают текущий тест (с помощью `t.Fatal`). Такие утилиты часто удобны при создании тестовых значений, например, в полях структур при использовании [таблицы тестов](https://google.github.io/styleguide/go/decisions#table-driven-tests), поскольку функции, возвращающие ошибки, не могут быть непосредственно присвоены полю структуры.
```
// Хорошо:
func mustMarshalAny(t testing.T, m proto.Message) anypb.Any {
  t.Helper()
  any, err := anypb.New(m)
  if err != nil {
    t.Fatalf("MustMarshalAny(t, m) = %v; want %v", err, nil)
  }
  return any
}
```
```
func TestCreateObject(t *testing.T) {
  tests := []struct{
    desc string
    data *anypb.Any
  }{
    {
      desc: "my test case",
      // Creating values directly within table driven test cases.
      data: mustMarshalAny(t, mypb.Object{}),
    },
    // ...
  }
  // ...
}
```
В обоих случаях значение этого шаблона в том, что утилиты могут быть вызваны в "контексте значения". Эти утилиты не следует вызывать в местах, где сложно гарантировать перехват ошибки или в контексте, где ошибку следует [проверять](https://google.github.io/styleguide/go/decisions#handle-errors) (например, во многих обработчиках запросов). В случае постоянных входных данных, это позволяет легко убедиться, что аргументы `Must` имеют правильную структуру, а для не постоянных входных данных это позволяет проверить, что ошибки [обрабатываются или передаются правильно](https://google.github.io/styleguide/go/best-practices#error-handling).

Если `Must` функции используются в тесте, их следует, как правило, пометить как [вспомогательные функции для тестов](https://google.github.io/styleguide/go/decisions#mark-test-helpers) и вызывать `t.Fatal` при возникновении ошибки (см. обработку ошибок в вспомогательных функциях для тестов для более детального рассмотрения этого вопроса).

Их не следует использовать, когда возможна [обычная обработка ошибок](https://google.github.io/styleguide/go/best-practices#error-handling) (включая возможность некоторого рефакторинга):
```
// Плохо:
func Version(o servicepb.Object) (version.Version, error) {
    // Возврат ошибки вместо использования Must функций.
    v := version.MustParse(o.GetVersionString())
    return dealiasVersion(v)
```

### Время жизни горутины

Когда вы создаете горутину, убедитесь, будет ли она завершена, и если да, то когда.

Горутины могут простаивать, если они блокируются на отправке или получении из канала. Сборщик мусора не завершает горутину, даже если каналы, на которых она блокирована, недоступны.

Даже если горутины не простаивают, оставление их в "полете", когда они больше не нужны, может вызвать другие тонкие и сложные проблемы, которые трудно диагностировать. Отправка в закрытый канал вызывает панику.
```
// Плохой пример:
ch := make(chan int)
ch <- 42
close(ch)
ch <- 13 // паника
```
Изменение входных данных, которые "уже не требуются", может привести к гонкам данных. Оставление горутин в "полете" на неопределенное время может привести к непредсказуемому использованию памяти.

Код, работающий параллельно, должен быть написан таким образом, чтобы время жизни горутин было явным. Обычно это означает ограничение кода синхронизации в рамках функции и разделение логики на [синхронные функции](https://google.github.io/styleguide/go/decisions#synchronous-functions). Если параллельность все равно не очевидна, важно задокументировать, когда и почему горутины завершаются.

Код, который следует лучшим практикам использования контекста, часто помогает сделать это понятным. Обычно он управляется с помощью `context.Context`:

```
// Хороший пример:
func (w *Worker) Run(ctx context.Context) error {
    // ...
    for item := range w.q {
        // process завершается, как только контекст отменен.
        go process(ctx, item)
    }
    // ...
}
```
Существуют другие варианты использования "сырых" сигнальных каналов, таких как `chan struct{}`, синхронизированных переменных, [условных переменных](https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view) и так далее. Главное, чтобы конец горутины был явен для последующих разработчиков.

В отличие от этого, следующий код не задумывается о том, когда его созданные горутины завершаются:
```
// Плохой пример:
func (w *Worker) Run() {
    // ...
    for item := range w.q {
        // process завершается, когда оно закончится, если вообще закончится,
        // возможно, не обрабатывая корректно переход состояния или завершение самой программы на Go.
        go process(item)
    }
    // ...
}
```
Этот код может выглядеть нормально, но в нем есть несколько проблем:
* Вероятно, код имеет неопределенное поведение в продакшене, и программа может не завершиться корректно, даже если операционная система освободит ресурсы.
* Код трудно осмысленно тестировать из-за неопределенного жизненного цикла кода.
* Из кода могут утекать ресурсы, как описано выше.

Смотрите также:
* [Не запускайте горутину, не зная, как она будет останавливаться](https://dave.cheney.net/2016/12/22/never-start-a-goroutine-without-knowing-how-it-will-stop)
* Переосмысление классических шаблонов параллелизма: [слайды](https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view), [видео](https://www.youtube.com/watch?v=5zXAHh5tJqQ)
* [Когда Go программы завершаются](https://changelog.com/gotime/165)

### Интерфейсы 

Обычно интерфейсы Go должны находиться в пакете, который использует значения типа интерфейса, а не в пакете, который реализует тип интерфейса. Реализующий пакет должен возвращать конкретные типы (обычно указатель или структуру). Таким образом, новые методы могут быть добавлены в реализации без необходимости обширного рефакторинга. Для получения более подробной информации смотрите [Совет по Go #49: Принимайте интерфейсы, возвращайте конкретные типы](https://google.github.io/styleguide/go/index.html#gotip).

Не экспортируйте реализацию [тестовой заглушки](https://abseil.io/resources/swe-book/html/ch13.html#techniques_for_using_test_doubles) интерфейса из API, которое его использует. Вместо этого спроектируйте API так, чтобы его можно было протестировать, используя [публичное API](https://abseil.io/resources/swe-book/html/ch12.html#test_via_public_apis) [реальной реализации](https://google.github.io/styleguide/go/best-practices#use-real-transports). Для получения более подробной информации смотрите [Совет по Go #42: Создание заглушки для тестирования](https://google.github.io/styleguide/go/index.html#gotip). Даже когда невозможно использовать реальную реализацию, не всегда необходимо создавать интерфейс, полностью описывающий все методы реального типа; потребитель может создать интерфейс, содержащий только нужные ему методы, как показано в [Совет по Go #78: Минимально жизнеспособные интерфейсы](https://google.github.io/styleguide/go/index.html#gotip).

Для тестирования пакетов, которые используют клиенты Stubby RPC, используйте реальное подключение клиента. Если невозможно запустить реальный сервер в тесте, Google рекомендует использовать реальное подключение клиента к локальной [тестовой заглушке](https://abseil.io/resources/swe-book/html/ch13.html#basic_concepts) с помощью внутреннего пакета `rpctest` (скоро появится!).

Не определяйте интерфейсы до их использования (см. [TotT: Код здоровья: Устраните запахи YAGNI](https://testing.googleblog.com/2017/08/code-health-eliminate-yagni-smells.html)). Без реалистичного примера использования трудно определить, нужен ли интерфейс и какие методы он должен содержать.

Не используйте параметры с типом интерфейса, если пользователям пакета не нужно передавать разные типы данных.

Не экспортируйте интерфейсы, которые необходимы только пользователю пакета.

TODO: Напишите более подробную документацию об интерфейсах и добавьте ссылку сюда.
```
// Хороший пример:
package consumer // consumer.go

type Thinger interface { Thing() bool }

func Foo(t Thinger) string { ... }
```
```
// Хороший пример:
package consumer // consumer_test.go

type fakeThinger struct{ ... }
func (t fakeThinger) Thing() bool { ... }
...
if Foo(fakeThinger{...}) == "x" { ... }
// Плохой пример:
package producer

type Thinger interface { Thing() bool }

type defaultThinger struct{ ... }
func (t defaultThinger) Thing() bool { ... }

func NewThinger() Thinger { return defaultThinger{ ... } }
```
```
// Хороший пример:
package producer

type Thinger struct{ ... }
func (t Thinger) Thing() bool { ... }

func NewThinger() Thinger { return Thinger{ ... } }
```

### Дженерики

Дженерики (официально называемые "[параметры типа](https://go.dev/design/43651-type-parameters)") разрешены, если они соответствуют вашим бизнес-требованиям. Во многих приложениях обычный подход, использующий существующие возможности языка (срезы, карты, интерфейсы и так далее), работает так же хорошо без дополнительной сложности, поэтому будьте осторожны с преждевременным использованием. См. обсуждение [наименьшего механизма](https://google.github.io/styleguide/go/guide#least-mechanism).

При введении экспортированного API, который использует обобщения, убедитесь, что он надлежащим образом задокументирован. Очень рекомендуется включить мотивирующие [примеры кода](https://google.github.io/styleguide/go/decisions#examples).

Не используйте обобщения только потому, что вы реализуете алгоритм или структуру данных, которая не обращает внимание на тип элементов. Если только один тип используется на практике, начните с написания кода для этого типа без использования обобщений. Добавление полиморфизма позднее будет проще, чем удаление ненужной абстракции.

Не используйте обобщения для создания специализированных языков предметной области (DSL). В частности, воздержитесь от введения фреймворков обработки ошибок, которые могут создать значительную нагрузку на пользователей. Вместо этого предпочтительнее использовать установленные практики [обработки ошибок](https://google.github.io/styleguide/go/decisions#errors). При тестировании особенно будьте осторожны с [библиотеками `"assert"`](https://google.github.io/styleguide/go/decisions#assert) или фреймворков, которые приводят к менее полезным [сбоям тестов](https://google.github.io/styleguide/go/decisions#useful-test-failures).

Резюмируя:

* [Пишите код, не проектируйте типы](https://www.youtube.com/watch?v=Pa_e9EeCdy8&t=1250s). Это совет из выступления на GopherCon, сделанного Робертом Гриземером и Иэном Лансом Тейлором.
* Если у вас есть несколько типов, которые имеют общий полезный интерфейс, рассмотрите моделирование решения с использованием этого интерфейса. Может быть, обобщения не понадобятся.
* В противном случае, вместо использования типа `any` и избыточного переключения типов рассмотрите использование [смены типа](https://tour.golang.org/methods/16).

См. также:

* [Использование обобщений в Go](https://www.youtube.com/watch?v=nr8EpUO9jhw), выступление Иэна Ланса Тейлора
* [Учебник по дженерикам](https://go.dev/doc/tutorial/generics) на веб-странице Go (Generics tutorial on Go’s webpage)


### Передача значений

Не передавайте указатели в качестве аргументов функции просто для экономии нескольких байт. Если функция читает свой аргумент `x` только как `*x` во всех случаях, то аргумент не должен быть указателем. Обычные примеры таких случаев включают передачу указателя на строку (`*string`) или указателя на значение интерфейса (`*io.Reader`). В обоих случаях само значение имеет фиксированный размер и может быть передано напрямую.

Этот совет не применяется к большим структурам или даже к маленьким структурам, которые могут увеличиться в размере. В частности, сообщения протокола буфера должны обычно обрабатываться с использованием указателя, а не значения. Тип указателя удовлетворяет интерфейсу `proto.Message` (принимается `proto.Marshal`, `protocmp.Transform` и т. д.), а сообщения протокола буфера могут быть довольно большими и часто увеличиваться по размеру со временем.

### Тип получателя

[Тип получателя](https://golang.org/ref/spec#Method_declarations) метода может быть передан как значение или указатель, так же, как если бы он был обычным параметром функции. Выбор между ними зависит от того, к какому [набору методов](https://golang.org/ref/spec#Method_sets) метод должен относиться.

**Корректность важнее скорости или простоты.** Есть случаи, когда необходимо использовать указатель. В других случаях выбирайте указатели для больших типов или для обеспечения переносимости кода ИЛИ если у вас нет хорошего представления о его росте — используйте [незамысловатые старые данные](https://en.wikipedia.org/wiki/Passive_data_structure).

Ниже приведен список каждого случая более подробно:

* Если получатель является срезом и метод не срезает или не перераспределяет срез, используйте значение, а не указатель.
```
// Хорошо:
type Buffer []byte

func (b Buffer) Len() int { return len(b) }
```
* Если метод должен изменять получатель, получатель должен быть указателем.
```
// Хорошо:
type Counter int

func (c Counter) Inc() { c++ }

// См. container / heap (https://pkg.go.dev/container/heap).
type Queue []Item

func (q Queue) Push(x Item) { q = append([]Item{x}, *q...) }
```
* Если получатель является структурой, содержащей поля, которые нельзя безопасно скопировать, используйте указатель. Общие примеры: `sync.Mutex` и другие типы синхронизации.
```
// Хорошо:
type Counter struct {
    mu    sync.Mutex
    total int
}

func (c *Counter) Inc() {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.total++
}
```
**Совет:** Проверьте [Godoc](https://pkg.go.dev/time#example-Duration) типа, чтобы узнать, безопасно ли его копировать или нет.

* Если получатель является "большой" структурой или массивом, указательный получатель может быть более эффективным. Передача структуры эквивалентна передаче всех ее полей или элементов в метод в качестве аргументов. Если это кажется слишком большим для [передачи по значению](https://google.github.io/styleguide/go/decisions#pass-values), указатель — хороший выбор.

* Для методов, которые будут вызываться или работать параллельно с другими функциями, изменяющими получатель, используйте значение, если эти изменения не должны быть видны вашему методу; в противном случае используйте указатель.

* Если получатель является структурой или массивом, любой из элементов которого является указателем на что-то, что может измениться, предпочтительнее использовать указатель, чтобы читателю было ясно, что изменения могут быть произведены.
```
// Хорошо:
type Counter struct {
    m *Metric
}

func (c *Counter) Inc() {
    c.m.Add(1)
}
```
* Если получатель является [встроенным типом](https://pkg.go.dev/builtin), таким как целое число или строка, которые не нуждаются в изменении, используйте значение.
```
// Хорошо:
type User string

func (u User) String() { return string(u) }
```
* Если получатель является картой, функцией или каналом, используйте значение, а не указатель.
```
// Хорошо:
// См. net / http # Header (https://pkg.go.dev/net/http#Header).
type Header map[string][]string

func (h Header) Add(key, value string) { / опущено / }
```
* Если получатель является "маленьким" массивом или структурой, который естественно является типом значения без изменяемых полей и указателей, обычно правильным выбором будет получатель значения.
```
// Хорошо:
// См. time # Time (https://pkg.go.dev/time#Time).
type Time struct { / опущено / }

func (t Time) Add(d Duration) Time { / опущено / }
```
* В случае сомнений используйте указатель.

В качестве общего руководства предпочтительнее делать методы для типа либо все указателем, либо все значением.

**Примечание:** Существует много ложной информации о том, может ли передача значения или указателя в функцию повлиять на производительность. Компилятор может выбрать передачу указателей на значения в стеке, а также копирование значений в стеке, но эти соображения не должны превалировать над читаемостью и правильностью кода в большинстве случаев. Когда производительность имеет значение, важно провести профилирование обоих подходов с помощью реалистичного бенчмарка, прежде чем решать, какой подход работает лучше.

### **`switch` и `break`**

Не используйте операторы `break` без меток лейблов в конце подвыражений в `switch`; они излишни. В отличие от языков C и Java, в `switch`-выражениях в Go автоматически используется оператор `break`, и для достижения поведения в стиле C требуется использовать оператор `fallthrough`. Используйте комментарий вместо оператора `break`, если вы хотите пояснить цель пустого подвыражения.
```
// Хорошо:
switch x {
case "A", "B":
    buf.WriteString(x)
case "C":
    // обработка за пределами выражения switch
default:
    return fmt.Errorf("неизвестное значение: %q", x)
}
```
```
// Плохо:
switch x {
case "A", "B":
    buf.WriteString(x)
    break // этот break излишен
case "C":
    break // этот break излишен
default:
    return fmt.Errorf("неизвестное значение: %q", x)
}
```
> **Примечание:** если выражение `switch` находится внутри цикла `for`, использование оператора `break` внутри выражения `switch` не прерывает охватывающий цикл.
>```
> for {
>   switch x {
>   case "A":
>      break // прерывает switch, но не цикл
>   }
> }
>```
> Чтобы выйти из охватывающего цикла, используйте метку на операторе `for`:
> ```
> loop:
>   for {
>     switch x {
>     case "A":
>        break loop // выходит из цикла
>     }
>   }
> ```
### Синхронные функции

Синхронные функции возвращают результаты непосредственно и завершают все обратные вызовы или операции с каналами перед возвратом. Предпочитайте синхронные функции асинхронным функциям.

Синхронные функции ограничивают горутины в рамках вызова. Это помогает обосновать их времени жизни и избежать утечек и состязаний данных. Синхронные функции также легче тестировать, поскольку вызывающий код может передать входные данные и проверить вывод без необходимости опроса или синхронизации.

При необходимости вызывающий код может добавить параллелизм, вызвав функцию в отдельной горутине. Однако довольно сложно (иногда невозможно) убрать ненужную параллельность на стороне вызывающего кода.

См. также:

“Rethinking Classical Concurrency Patterns”, доклад Брайана Миллса: [слайды](https://drive.google.com/file/d/1nPdvhB0PutEJzdCq5ms6UI58dp50fcAN/view), [видео](https://www.youtube.com/watch?v=5zXAHh5tJqQ)

### Псевдонимы типов

Используйте определение типа, `type T1 T2`, для определения нового типа. Используйте [псевдоним типа](http://golang.org/ref/spec#Type_declarations), `type T1 = T2`, чтобы сослаться на существующий тип без определения нового типа. Псевдонимы типов редки; их основное применение - помощь в миграции пакетов на новые исходные коды. Не используйте псевдонимирование типов, когда это не требуется.


### Используйте `%q`

В функциях форматирования Go (`fmt.Printf` и т. д.) есть символ `%q`, который выводит строки в двойных кавычках.
```
// Хорошо:
fmt.Printf("значение %q похоже на текст на английском языке", someText)
```
Предпочитайте использовать %q вместо ручного эквивалента, используя %s:
```
// Плохо:
fmt.Printf("значение \"%s\" похоже на текст на английском языке", someText)
// Избегайте ручной обертки строк одинарными кавычками:
fmt.Printf("значение '%s' похоже на текст на английском языке", someText)
```
Использование `%q` рекомендуется в выводе, предназначенном для людей, где входное значение может быть пустым или содержать управляющие символы. Очень сложно заметить молчаливую пустую строку, но `""` явно выделяется как таковая.


### Используйте `any`
Go 1.18 представляет новый тип `any` как [псевдоним](https://go.googlesource.com/proposal/+/master/design/18130-type-alias.md) для `interface{}`. Поскольку это псевдоним, `any` эквивалентен `interface{}` во многих ситуациях, а в других случаях его можно легко использовать с помощью явного преобразования. Предпочтительнее использовать `any` в новом коде.

## Встроенные библиотеки

### Флаги

Программы на Go в кодовой базе Google используют внутренний вариант [стандартного пакета `flag`](https://golang.org/pkg/flag/). Он имеет похожий интерфейс, но хорошо совместим с внутренними системами Google. Имена флагов в двоичных файлах Go должны предпочтительно использовать подчеркивания для разделения слов, хотя переменные, которые содержат значение флага, должны следовать стандартному стилю имени Go ([смешанные заглавные буквы](https://google.github.io/styleguide/go/guide#mixed-caps)). Конкретно имя флага должно быть в стиле snake case, а имя переменной - эквивалентным имени в стиле camel case.
```
// Хорошо:
var (
    pollInterval = flag.Duration("poll_interval", time.Minute, "Интервал использования при опросе.")
)
```
```
// Плохо:
var (
    poll_interval = flag.Int("pollIntervalSeconds", 60, "Интервал использования при опросе в секундах.")
)
```
Флаги должны быть определены только в пакете `main` или эквивалентном.

Пакеты общего назначения должны быть настроены с использованием API Go, а не через командный интерфейс; не допускайте использование импорта библиотеки для экспорта новых флагов в качестве побочного эффекта. Иначе говоря, предпочтительнее использовать явные аргументы функций или присваивание полей структур, или намного реже и только при строгей проверке экспортированные глобальные переменные. В крайне редком случае, когда необходимо нарушить это правило, имя флага должно ясно указывать на то, какой пакет он настраивает.

Если ваши флаги являются глобальными переменными, поместите их в свою собственную группу `var`, следуя разделу импорта.

Вокруг создания [сложных CLI](https://google.github.io/styleguide/go/best-practices#complex-clis) с подкомандами ведется дополнительное обсуждение.

См. также:

* [Совет недели #45: Избегайте флагов, особенно в библиотечном коде](https://abseil.io/tips/45)
* [Совет по Go #10: Управление настройками с помощью структур и флагов](https://google.github.io/styleguide/go/index.html#gotip)
* [Совет по Go #80: Принципы внедрения зависимостей](https://google.github.io/styleguide/go/index.html#gotip)

### Логирование

Программы на Go в кодовой базе Google используют вариант [стандартного пакета `log`](https://pkg.go.dev/log). Он имеет похожий, но более мощный интерфейс и хорошо совместим с внутренними системами Google. Открытая версия этой библиотеки доступна в качестве [пакета `glog`](https://pkg.go.dev/github.com/golang/glog), и открытые проекты Google могут использовать ее, но в этом руководстве на нее ссылается как на `log`.

**Примечание:** Для нештатного завершения программы эта библиотека использует `log.Fatal` для аварийного завершения с трассировкой стека и `log.Exit` для остановки без трассировки. В стандартной библиотеке отсутствует функция `log.Panic`.

**Совет:** `log.Info(v)` эквивалентно `log.Infof("%v", v)`, и то же самое относится к другим уровням логирования. Предпочтительно использовать версию без форматирования, когда нет необходимости в форматировании.

См. также:

* Лучшие практики по [логированию ошибок](https://google.github.io/styleguide/go/best-practices#error-logging) и [настраиваемым уровням детализации](https://google.github.io/styleguide/go/best-practices#vlog)
* Когда и как использовать пакет `log` для [остановки программы](https://google.github.io/styleguide/go/best-practices#checks-and-panics)

### Контексты

Значения типа [`context.Context`](https://pkg.go.dev/context) передают учетные данные безопасности, информацию о трассировке, сроки и сигналы отмены через границы API и процессов. В отличие от C++ и Java, которые в кодовой базе Google используют хранилище с локальными потоками, программы на Go явно передают контексты вдоль всей цепочки вызовов функций от входящих RPC и HTTP-запросов до исходящих запросов.

Когда передается в функцию или метод, `context.Context` всегда является первым параметром.
```
func F(ctx context.Context /* другие аргументы */) {}
```
Исключения:

* В обработчике HTTP, где контекст берется из [`req.Context()`](https://pkg.go.dev/net/http#Request.Context).
* В методах потокового RPC, где контекст берется из потока.
  При использовании потокового gRPC доступ к контексту осуществляется с помощью метода `Context()` в сгенерированном типе сервера, который реализует `grpc.ServerStream`. См. [документацию по сгенерированному коду gRPC](https://grpc.io/docs/languages/go/generated-code/).

* В точках входа функций (см. ниже примеры таких функций) используйте [`context.Background()`](https://pkg.go.dev/context/#Background).
  * В функциях точки входа (см. примеры ниже) используйте context.Background().
  * В бинарных целях: `main`
  * В общем коде и библиотеках: `init`
  * В тестах: `TestXXX`, `BenchmarkXXX`, `FuzzXXX`

> **Примечание:** очень редко коду в середине цепочки вызовов требуется создание своего собственного базового контекста с использованием `context.Background()`. Всегда предпочитайте использовать контекст из вызывающего кода, если это не является неверным контекстом.
> 
> Возможно, вам придется столкнуться с серверными библиотеками (реализация Stubby, gRPC или HTTP в серверном фреймворке Google для Go), которые создают новый объект контекста для каждого запроса. Эти контексты сразу заполняются информацией из входящего запроса, так что когда они передаются обработчику запросов, значения, присоединенные к контексту, были переданы ему через сетевую границу от вызывающего клиента. Кроме того, срок действия этих контекстов ограничен сроком обработки запроса: когда запрос завершается, контекст отменяется.
> 
> Если вы не реализуете серверный фреймворк, в библиотечном коде не следует создавать контексты с использованием `context.Background()`. Лучше используйте открепление контекста, о котором упоминается ниже, если уже существует контекст. Если вы все-таки считаете нужным использовать `context.Background()` за пределами функций точки входа, обсудите это на списке рассылки Google Go style до реализации.

Соглашение, что `context.Context` должен быть первым параметром в функциях, также применяется к тестовым вспомогательным функциям.
```
// Хорошо:
func readTestFile(ctx context.Context, t *testing.T, path string) string {}
```
Не добавляйте член контекста к типу структуры. Вместо этого добавьте параметр контекста к каждому методу типа, который нуждается в передаче его дальше. Единственное исключение - для методов, сигнатура которых должна соответствовать интерфейсу в стандартной библиотеке или в сторонней библиотеке, не контролируемой Google. Такие случаи очень редки и следует обсуждать на списке рассылки Google Go style до реализации и обзора читаемости кода.

Код в базе кода Google, который должен запускать фоновые операции, которые могут выполняться после отмены родительского контекста, может использовать внутренний пакет для отделения. Читайте [проблемы #40221](https://github.com/golang/go/issues/40221) для обсуждения альтернатив с открытым исходным кодом.

Так как контексты неизменяемы, не вызывает проблем передавать один и тот же контекст в несколько вызовов, которые используют одни и те же сроки дедлайна, сигнал отмены, учетные данные, родительскую трассировку и так далее.

Смотрите также:
* [Контексты и структуры](https://go.dev/blog/context-and-structs)

### Свои контексты

Не создавайте свои типы контекста или используйте интерфейсы, отличные от `context.Context` в сигнатурах функций. Нет исключений для этого правила.

Представьте, что у каждой команды был собственный контекст. Каждый вызов функции из пакета `p` в пакет `q` должен был бы определить, как преобразовать `p.Context` в `q.Context` для всех пар пакетов `p` и `q`. Это не практично и подвержено ошибкам, и автоматические рефакторинги, которые добавляют параметры контекста, становятся практически невозможными.

Если у вас есть данные приложения для передачи, поместите их в параметр, в получателе, в глобальные переменные или в значение `Context`, если они действительно относятся к нему. Создание собственного типа контекста недопустимо, так как это подрывает возможность команды Go создавать работающие программы на Go в производственной среде.


### crypto/rand

Не используйте пакет `math/rand` для генерации ключей, даже временных. Если не позиционировать, генератор полностью предсказуем. Если создать сид с `time.Nanoseconds()`, есть всего несколько бит энтропии. Вместо этого используйте `Reader` из пакета `crypto/rand` и, если вам нужен текст, выводите его в шестнадцатеричном или base64 формате.
```
// Хорошо:
import (
    "crypto/rand"
    // "encoding/base64"
    // "encoding/hex"
    "fmt"

    // ...
)

func Key() string {
    buf := make([]byte, 16)
    if _, err := rand.Read(buf); err != nil {
        log.Fatalf("Исчерпаны случайные числа, такого не должно происходить: %v", err)
    }
    return fmt.Sprintf("%x", buf)
    // или hex.EncodeToString(buf)
    // или base64.StdEncoding.EncodeToString(buf)
}
```

**Примечание:** `log.Fatalf` не является частью стандартной библиотеки log. См. раздел [Логирование](https://google.github.io/styleguide/go/decisions#logging).

## Полезные ошибки тестирования

Возможно диагностировать проблему сбоя теста, не читая исходный код теста. Тесты должны завершаться с полезными сообщениями, содержащими следующую информацию:

* Что вызвало сбой
* Какие входные данные вызвали ошибку
* Фактический результат
* Что ожидалось

Конкретные соглашения для достижения этой цели описаны ниже.


### библиотеки утверждений

Не создавайте "библиотеки утверждений" в качестве помощников для тестирования.

Библиотеки утверждений - это библиотеки, которые пытаются объединить проверку и создание сообщений об ошибке в пределах теста (хотя те же проблемы могут возникать и с другими помощниками для тестирования). Дополнительную информацию о различии между помощниками для тестирования и библиотеки утверждений, смтори [лучшие практики](https://google.github.io/styleguide/go/best-practices#test-functions).
```
// Неправильно:
var obj BlogPost

assert.IsNotNil(t, "obj", obj)
assert.StringEq(t, "obj.Type", obj.Type, "blogPost")
assert.IntEq(t, "obj.Comments", obj.Comments, 2)
assert.StringNotEq(t, "obj.Body", obj.Body, "")
```
Assetion библиотеки, как правило, либо прекращают выполнение теста заранее (если `assert` вызывает `t.Fatalf` или `panic`), либо не содержат актуальной информации о том, что тест был выполнен правильно:
```
// Плохо:
package assert

func IsNotNil(t *testing.T, name string, val interface{}) {
    if val == nil {
        t.Fatalf("data %s = nil, want not nil", name)
    }
}

func StringEq(t *testing.T, name, got, want string) {
    if got != want {
        t.Fatalf("data %s = %q, want %q", name, got, want)
    }
}
```
Сложные функции проверки утверждений часто не предоставляют [полезных сообщений об ошибках](https://google.github.io/styleguide/go/decisions#useful-test-failures) и контекста, который существует внутри функции тестирования. Слишком много функций проверки утверждений и библиотек приводит к фрагментации опыта разработчика: какую библиотеку проверки утверждений следует использовать, в каком стиле она должна выводить форматирование и т.д.? Фрагментация приводит к избыточному недопониманию, особенно для поддержки библиотек и авторов большомасштабных изменений, которые несут ответственность за исправление возможных ошибок в зависимых проектах. Вместо создания специализированного языка для тестирования использовать сам Go.

Библиотеки утверждений часто выносят проверки и сравнения. Предпочитайте использовать стандартные библиотеки, такие как [`cmp`](https://pkg.go.dev/github.com/google/go-cmp/cmp) и [`fmt`](https://golang.org/pkg/fmt/):
```
//Хорошо:
var got BlogPost

want := BlogPost{
    Comments: 2,
    Body:     "Hello, world!",
}

if !cmp.Equal(got, want) {
    t.Errorf("blog post = %v, want = %v", got, want)
}
```
Для более специфичных помощников сравнения домена предпочтительнее возвращать значение или ошибку, которые можно использовать в сообщении об ошибке теста, вместо передачи `*testing.T` и вызова его методов сообщения об ошибке:
```
// Хорошо:
func postLength(p BlogPost) int { return len(p.Body) }

func TestBlogPost_VeritableRant(t *testing.T) {
    post := BlogPost{Body: "I am Gunnery Sergeant Hartman, your senior drill instructor."}

    if got, want := postLength(post), 60; got != want {
        t.Errorf("length of post = %v, want %v", got, want)
    }
}
```
**Лучшая практика:** Если `postLength` является нетривиальной функцией, имеет смысл протестировать ее напрямую, независимо от любых тестов, которые ее используют.

См. также:

* [Сравнение равенства и различий](https://google.github.io/styleguide/go/decisions#types-of-equality)
* [Вывод различий](https://google.github.io/styleguide/go/decisions#print-diffs)
* Дополнительную информацию о различии между помощниками для тестирования и помощниками для утверждений смотри в [лучших практиках](https://google.github.io/styleguide/go/best-practices#test-functions).

### Определение функции

В большинстве тестов сообщения об ошибках должны включать имя функции, в которой произошла ошибка, даже если это кажется очевидным по имени функции теста. В частности, сообщение об ошибке должно быть `YourFunc(%v) = %v, want %v` вместо просто `got %v, want %v`.

### Определение входных данных

В большинстве тестов сообщения об ошибках должны включать входные данные функции, если они являются короткими. Если соответствующие свойства входных данных не очевидны (например, потому что входные данные большие или непрозрачные), вы должны именовать случаи тестирования с описанием того, что тестируется, и выводить это описание в сообщение об ошибке.

### `got` всегда перед `want`

Результаты теста должны включать фактическое значение, которое возвращает функция, перед выводом значения, которое ожидалось. Стандартный формат для вывода результатов теста - `YourFunc(%v) = %v, want %v`. Где вместо "фактическое" и "ожидаемое" предпочтительно использовать слова "got" и "want" соответственно.

Для различий направленность менее очевидна, и поэтому важно включить ключ, который поможет в интерпретации сбоя. Смотрите раздел о [печати различий](https://google.github.io/styleguide/go/decisions#print-diffs). Какой бы порядок diff вы ни использовали в своих сообщениях о сбоях, вы должны явно указать его как часть сообщения об ошибке, поскольку существующий код несогласован с порядком.

### Сравнение заполненной структуры

Если ваша функция возвращает структуру (или любой другой тип данных с несколькими полями, такими как срезы, массивы и карты), избегайте написания тестового кода, выполняющего сравнение полей структуры вручную. Вместо этого создайте данные, которые вы ожидаете получить от вашей функции, и сравните их непосредственно с помощью [глубокого сравнения](https://google.github.io/styleguide/go/decisions#types-of-equality).

**Примечание:** это не относится к случаю, когда ваши данные содержат ненужные поля, которые затрудняют понимание намерений теста.

Если вашу структуру нужно сравнивать на приблизительное (или эквивалентное по семантике) равенство или она содержит поля, которые нельзя сравнить на равенство (например, если одно из полей является `io.Reader`), для этого может подойти использование сравнения с помощью [`cmp.Diff`](https://pkg.go.dev/github.com/google/go-cmp/cmp#Diff) или [`cmp.Equal`](https://pkg.go.dev/github.com/google/go-cmp/cmp#Equal) с использованием опций [`cmpopts`](https://pkg.go.dev/github.com/google/go-cmp/cmp/cmpopts), таких как [`cmpopts.IgnoreInterfaces`](https://pkg.go.dev/github.com/google/go-cmp/cmp/cmpopts#IgnoreInterfaces) ([пример](https://play.golang.org/p/vrCUNVfxsvF)).

Если ваша функция возвращает несколько значений, вам не нужно оборачивать их в структуру перед сравнением. Просто сравнивайте возвращаемые значения по отдельности и выводите их.
```
// Хорошо:
val, multi, tail, err := strconv.UnquoteChar("Закусочная Fran & Freddie", '"')
if err != nil {
  t.Fatalf(...)
}
if val != "Закусочная Fran & Freddie" {
  t.Errorf(...)
}
if multi {
  t.Errorf(...)
}
if tail != "Diner" {
  t.Errorf(...)
}
```

### Сравнение стабильных результатов

Избегайте сравнения результатов, которые могут зависеть от стабильности вывода пакета, которым вы не владеете. Вместо этого тест должен сравнивать семантически значимую информацию, стабильную и устойчивую к изменениям зависимостей. Для функциональности, которая возвращает отформатированную строку или сериализованные байты, обычно нельзя предполагать, что вывод стабилен.

Например, [`json.Marshal`](https://golang.org/pkg/encoding/json/#Marshal) может изменяться (и менялся в прошлом) в отношении конкретных байтов, которые он генерирует. Тесты, которые выполняют сравнение строк посимвольно, могут сломаться, если пакет `json` изменит способ сериализации байтов. Вместо этого более надежным будет разбор содержимого строки JSON и проверка его семантического эквивалента некоторой ожидаемой структуре данных.

### Продолжайте

Тесты должны продолжать выполнение как можно дольше, даже после ошибки, чтобы можно было вывести все неудачные проверки в одном запуске. Так разработчику, исправляющему ошибку, не придется каждый раз запускать тест для поиска следующей ошибки после исправления предыдущей.

При сравнении лучше использовать вызов `t.Error` вместо `t.Fatal`, чтобы сообщить о несоответствии. Когда необходимо сравнивать несколько разных свойств вывода функции, используйте `t.Error` для каждого из этих сравнений.

Вызов `t.Fatal` применяется в основном для сообщения о неожиданном условии ошибки, когда последующие сравнения не будут иметь смысла.

Для табличного тестирования рассмотрите использование подтестов и используйте `t.Fatal` вместо `t.Error` и `continue`. См. также [Совет по Go #25: Подтесты: Как сделать ваши тесты более компактными](https://google.github.io/styleguide/go/index.html#gotip).

**Лучшая практика:** Для обсуждения того, когда следует использовать `t.Fatal`, смотри [лучшие практики](https://google.github.io/styleguide/go/best-practices#t-fatal).

### Сравнение равенства и различий

Оператор `==` оценивает равенство с использованием [определенных языком сравнений](http://golang.org/ref/spec#Comparison_operators). Скалярные значения (числа, булевы значения и т. д.) сравниваются на основе их значений, но только некоторые структуры и интерфейсы можно сравнивать таким образом. Указатели сравниваются на основе того, указывают ли они на одну и ту же переменную, а не на основе равенства значений, на которые они указывают.

Пакет [`cmp`](https://pkg.go.dev/github.com/google/go-cmp/cmp) может сравнивать более сложные структуры данных, с которыми оператор `==` некорректно работает, например, срезы. Используйте [`cmp.Equal`](https://pkg.go.dev/github.com/google/go-cmp/cmp#Equal) для сравнения равенства и [`cmp.Diff`](https://pkg.go.dev/github.com/google/go-cmp/cmp#Diff) для получения человеко-читаемых различий между объектами.
```
// Хорошо:
want := &Doc{
    Type:     "blogPost",
    Comments: 2,
    Body:     "This is the post body.",
    Authors:  []string{"isaac", "albert", "emmy"},
}
if !cmp.Equal(got, want) {
    t.Errorf("AddPost() = %+v, want %+v", got, want)
}
```
`cmp`, как универсальная библиотека сравнения, может не знать, как сравнивать некоторые типы. Например, он может только сравнивать сообщения протоколов буферизации при использовании параметра [`protocmp.Transform`](https://pkg.go.dev/google.golang.org/protobuf/testing/protocmp#Transform).
```
// Хорошо:
if diff := cmp.Diff(want, got, protocmp.Transform()); diff != "" {
    t.Errorf("Foo() вернул неожиданное отличие в сообщениях протоколов буферизации (-want +got):\n%s", diff)
}
```
Хотя пакет `cmp` не является частью стандартной библиотеки Go, он поддерживается командой разработчиков Go и должен обеспечивать стабильные результаты сравнения со временем. Он предоставляет настраиваемые возможности и должен удовлетворять большинству потребностей в сравнении.

Существующий код может использовать следующие старые библиотеки и может продолжать их использовать для обеспечения согласованности:

* [`pretty`](https://pkg.go.dev/github.com/kylelemons/godebug/pretty) создает отчеты о различиях, которые эстетически приятны. Однако он намеренно считает одинаковыми значения, имеющие одинаковое визуальное представление. В частности, pretty не выявляет различий между нулевыми срезами и пустыми срезами, не учитывает разные реализации интерфейсов с идентичными полями, и можно использовать вложенное отображение в качестве основы для сравнения с структурным значением. Он также сериализует весь объект в строку перед созданием отчета о различиях и, таким образом, не является хорошим выбором для сравнения больших объектов. По умолчанию он сравнивает непубличные поля, что делает его чувствительным к изменениям в деталях реализации ваших зависимостей. Поэтому не рекомендуется использование pretty для сравнения сообщений протоколов буферизации.
Предпочтительно использовать cmp для нового кода, и стоит рассмотреть обновление старого кода для использования cmp, где это практически возможно.

Старый код может использовать функцию `reflect.DeepEqual` стандартной библиотеки для сравнения сложных структур. `reflect.DeepEqual` не должен использоваться для проверки равенства, так как он чувствителен к изменениям в непубличных полях и других деталях реализации. Код, который использует `reflect.DeepEqual`, следует обновить для использования одной из вышеупомянутых библиотек.

**Примечание:** Пакет `cmp` разработан для тестирования, а не для использования в продакшн коде. В связи с этим, он может вызывать панику, если сравнение выполнено некорректно, чтобы предоставить пользователям инструкции по улучшению теста для более надежного выполнения. Учитывая склонность `cmp` к вызову паники, он не подходит для использования в коде, который используется в продакшн, так как неожиданный сбой может быть фатальным.

### Уровень детализации

Традиционное сообщение об ошибке, подходящее для большинства тестов на Go, имеет следующий вид: `YourFunc(%v) = %v, want %v`. Однако существуют случаи, когда может потребоваться больше или меньше деталей:

* Тесты, выполняющие сложные взаимодействия, также должны описывать эти взаимодействия. Например, если функция `YourFunc` вызывается несколько раз, укажите, какой вызов привел к неуспешному тесту. Если важно знать дополнительное состояние системы, включите это в вывод ошибки (или, по крайней мере, в логи).
* Если данные представляют собой сложную структуру с большим количеством шаблонного кода, допустимо описывать только важные части в сообщении об ошибке, но не перегружайте информацией.
* Сбои на этапе настройки не требуют такого же уровня детализации. Если помощник теста заполняет таблицу `Spanner`, но `Spanner` недоступен, вам, вероятно, не нужно указывать, какие входные данные теста вы собирались сохранить в базе данных. `t.Fatalf("Setup: Failed to set up test database: %s", err)` обычно достаточно полезно для устранения проблемы.

**Подсказка:** Вызовите срабатывание режима сбоя во время разработки. Ознакомьтесь с тем, как выглядит сообщение об ошибке и будет ли разработчику эффективно справиться с этим сбоем.

Есть несколько техник для ясного воспроизведения входных и выходных данных теста:

* При печати строковых данных [часто полезно использовать `%q`](https://google.github.io/styleguide/go/decisions#use-percent-q), чтобы подчеркнуть важность значения и легче обнаружить некорректные значения.
* При печати (небольших) структур `%+v` может быть более полезным, чем `%v`.
* При сбое проверки более крупных значений [печать различия между ними](https://google.github.io/styleguide/go/decisions#print-diffs) может упростить понимание причины сбоя.

### Вывод различий

Если ваша функция возвращает большой вывод, то при сбое теста может быть сложно для читателя найти различия в сообщении об ошибке. Вместо печати как возвращаемого значения, так и ожидаемого значения, создайте различие.

Для вычисления различий для таких значений предпочтительнее использовать `cmp.Diff`, особенно для новых тестов и нового кода, но можно использовать и другие инструменты. Подробнее см. [типы сравнения](https://google.github.io/styleguide/go/decisions#types-of-equality) для руководства по преимуществам и недостаткам каждой функции.

* [`cmp.Diff`](https://pkg.go.dev/github.com/google/go-cmp/cmp#Diff)
* [`pretty.Compare`](https://pkg.go.dev/github.com/kylelemons/godebug/pretty#Compare)

Вы можете использовать пакет [`diff`](https://pkg.go.dev/github.com/kylelemons/godebug/diff) для сравнения многострочных строк или списков строк. Это можно использовать в качестве основы для других типов различий.

Добавьте к сообщению об ошибке текст, поясняющий направление различия.

* Что-то вроде `diff (-want +got)` подходит, когда вы используете пакеты `cmp`, `pretty` и `diff` (если передаете `(want, got)` в функцию), потому что знаки `-` и `+` в вашей строке формата будут соответствовать символам `-` и `+` в начале строк различий. Если вы передаете `(got, want)` в свою функцию, правильным ключом будет `(-got +want)`.
* Пакет `messagediff` использует другой формат вывода, поэтому при его использовании подходит сообщение об ошибке `diff` `(want -> got)` (если передаете `(want, got)` в функцию), потому что направление стрелки будет соответствовать направлению стрелки в строках "modified".

Различие будет охватывать несколько строк, поэтому перед печатью различия следует вывести символ новой строки.

### Ошибка семантики теста

Когда модульный тест выполняет сравнение строк или использует обычное `cmp` для проверки, что для определенных входных данных возвращаются определенные виды ошибок, вы можете обнаружить, что ваши тесты становятся хрупкими, если любые из этих сообщений об ошибках будут переформулированы в будущем. Поскольку это может превратить ваш модульный тест в детектор изменений (см. [TotT: Тесты на детекторе изменений вредные](https://testing.googleblog.com/2015/01/testing-on-toilet-change-detector-tests.html)), не используйте сравнение строк для проверки типа ошибки, возвращаемой вашей функцией. Однако можно использовать сравнение строк, чтобы проверить, что сообщения об ошибках, поступающие из тестируемого пакета, удовлетворяют определенным свойствам, например, чтобы они включали имя параметра.

Значения ошибок в Go обычно имеют составляющую, предназначенную для человеческого восприятия и составляющую, предназначенную для семантического управления потоком. Тесты должны стремиться проверять только семантическую информацию, которую можно надежно наблюдать, а не отображать информацию, предназначенную для отладки человеком, так как она часто подвержена будущим изменениям. Для руководства по созданию ошибок с семантическим значением, см. [лучшие практики в отношении ошибок](https://google.github.io/styleguide/go/best-practices#error-handling). Если ошибка с недостаточной семантической информацией поступает из зависимости, не подконтрольной вам, рассмотрите возможность сообщить об ошибке владельцу, чтобы помочь улучшить API, вместо того чтобы полагаться на разбор сообщения об ошибке.

В рамках модульных тестов обычно важно только то, произошла ошибка или нет. Если да, то достаточно просто проверить, что ошибка была не равна `nil`, когда вы ожидали ошибку. Если вы хотите проверить, что ошибка семантически соответствует другой ошибке, рассмотрите использование `cmp` с [`cmpopts.EquateErrors`](https://pkg.go.dev/github.com/google/go-cmp/cmp/cmpopts#EquateErrors).

> **Примечание:** Если тест использует [`cmpopts.EquateErrors`](https://pkg.go.dev/github.com/google/go-cmp/cmp/cmpopts#EquateErrors), но все его значения `wantErr` либо `nil`, либо `cmpopts.AnyError`, то использование `cmp` является [избыточным механизмом](https://google.github.io/styleguide/go/guide#least-mechanism). Упростите код, сделав поле `want` типа `bool`. Затем вы сможете использовать простое сравнение с `!=`.
> ```
> // Хорошо:
> gotErr := f(test.input) != nil
> if gotErr != test.wantErr {
>     t.Errorf("f(%q) вернул err = %v, ожидалась присутствие ошибки = %v", test.input, gotErr, test.wantErr)
> }
> ```
См. также [Совет по Go #13: Разработка ошибок для проверки](https://google.github.io/styleguide/go/index.html#gotip).


## Структура теста

### Подтесты

Стандартная библиотека тестирования Go предлагает возможность [определения подтестов](https://pkg.go.dev/testing#hdr-Subtests_and_Sub_benchmarks). Это даёт гибкости в установке и очистке, управлении параллелизмом и фильтрации тестов. Подтесты могут быть полезными (особенно для тестов на основе таблицы), но их использование не является обязательным. См. также [пост в блоге Go о подтестах](https://blog.golang.org/subtests).

Подтесты не должны зависеть от выполнения других случаев для успешного выполнения или начального состояния, поскольку ожидается возможность запуска подтестов индивидуально с использованием флагов `go test -run` или с выражениями [фильтра тестов](https://bazel.build/docs/user-manual#test-filter) Bazel.

#### Имена подтестов

Называйте свои подтесты так, чтобы они читались в выводе теста и были полезными при использовании командной строки для пользователей фильтрации тестов. Когда вы используете `t.Run` для создания подтеста, первый аргумент используется в качестве описательного имени теста. Чтобы убедиться, что результаты теста читаемы для людей, выбирайте имена подтестов, которые останутся полезными и читаемыми после экранирования. Подумайте о названиях подтестов как о идентификаторе функции, а не о прозаическом описании. При запуске тестов заменяются пробелы на символы подчеркивания и экранируются непечатаемые символы. Если ваши тестовые данные зависит от более длинного описания, рассмотрите возможность помещения описания в отдельное поле (возможно, которое будет напечатано с помощью `t.Log` или рядом с сообщениями об ошибке).

Подтесты могут быть запущены индивидуально с использованием флагов [запуска тестов Go](https://golang.org/cmd/go/#hdr-Testing_flags) или [фильтра тестов](https://bazel.build/docs/user-manual#test-filter) Bazel, поэтому выбирайте понятные имена, которые также легко набрать.

> **Предупреждение:** символы слэша особенно неприязненны в именах подтестов, так как они имеют [специальное значение для фильтров тестов](https://blog.golang.org/subtests#:~:text=Perhaps%20a%20bit,match%20any%20tests).
> > ```
> > // Плохо:
> > // Предположим, что есть тест TestTime и t.Run
> > ("America/New_York", ...)
> > bazel test :mytest --test_filter="Time/New_York"    // Ничего не запускает!
> > bazel test :mytest --test_filter="Time//New_York"   // Правильно, но некорректно.
> > ```

Чтобы [идентифицировать входные данные](https://google.github.io/styleguide/go/decisions#identify-the-input) функции, включите их в сообщения о сбоях теста, где они не будут пропущены исполнителем теста.

```
// Хорошо:
func TestTranslate(t *testing.T) {
    data := []struct {
        name, desc, srcLang, dstLang, srcText, wantDstText string
    }{
        {
            name:        "hu=en_bug-1234",
            desc:        "регрессионный тест после исправления ошибки 1234. контакт: cleese",
            srcLang:     "hu",
            srcText:     "cigarettát és egy öngyújtót kérek",
            dstLang:     "en",
            wantDstText: "cigarettes and a lighter please",
        }, // ...
    }
    for _, d := range data {
        t.Run(d.name, func(t *testing.T) {
            got := Translate(d.srcLang, d.dstLang, d.srcText)
            if got != d.wantDstText {
                t.Errorf("%s\nTranslate(%q, %q, %q) = %q, ожидалось: %q",
                    d.desc, d.srcLang, d.dstLang, d.srcText, got, d.wantDstText)
            }
        })
    }
}
```
Вот несколько примеров того, чего следует избегать:
```
// Плохо:
// Слишком многословно.
t.Run("проверка отсутствия упоминания поцарапанных пластинок или судоходных судов", ...)
// Вертикальные черты вызывают проблемы при использовании командной строки.
t.Run("путаница между AM/PM", ...)
```

### Тесты на основе таблицы
Используйте тесты на основе таблицы, когда можно протестировать много разных случаев с использованием схожей логики тестирования.

* Когда проверяется, равен ли фактический вывод функции ожидаемому выводу. Например, [множество тестов `fmt.Sprintf`](https://cs.opensource.google/go/go/+/master:src/fmt/fmt_test.go) или минимальный фрагмент кода ниже.
* Когда проверяется, соответствуют ли выводы функции всегда одному набору инвариантов. Например, [тесты для `net.Dial`](https://cs.opensource.google/go/go/+/master:src/net/dial_test.go;l=318;drc=5b606a9d2b7649532fe25794fa6b99bd24e7697c).

Вот минимальная структура теста на основе таблицы, взятая из стандартной библиотеки `strings`. При необходимости вы можете использовать другие имена, переместить срез с тестовыми значениями внутрь функции теста или добавить дополнительные возможности, такие как подтесты или функции настройки и очистки. Всегда помните о [полезности информации об ошибках в тестах](https://google.github.io/styleguide/go/decisions#useful-test-failures).
```
// Хорошо:
var compareTests = []struct {
    a, b string
    i    int
}{
    {"", "", 0},
    {"a", "", 1},
    {"", "a", -1},
    {"abc", "abc", 0},
    {"ab", "abc", -1},
    {"abc", "ab", 1},
    {"x", "ab", 1},
    {"ab", "x", -1},
    {"x", "a", 1},
    {"b", "x", -1},
    // тестирование chunked-реализации runtime·memeq
    {"abcdefgh", "abcdefgh", 0},
    {"abcdefghi", "abcdefghi", 0},
    {"abcdefghi", "abcdefghj", -1},
}

func TestCompare(t *testing.T) {
    for _, tt := range compareTests {
        cmp := Compare(tt.a, tt.b)
        if cmp != tt.i {
            t.Errorf(Compare(%q, %q) = %v, tt.a, tt.b, cmp)
        }
    }
}
```
**Примечание:** Сообщения об ошибках в приведенном выше примере соответствуют рекомендации [указать имя функции](https://google.github.io/styleguide/go/decisions#identify-the-function) и [указать входные данные](https://google.github.io/styleguide/go/decisions#identify-the-input). Нет необходимости [идентифицировать строку числовым образом](https://google.github.io/styleguide/go/decisions#table-tests-identifying-the-row).

Если некоторые тестовые случаи должны быть проверены с использованием другой логики, чем у других случаев, то более подходящим будет написание нескольких функций тестирования, как объясняется в [Совет по Go #50: Тесты с непересекающимися таблицами](https://google.github.io/styleguide/go/index.html#gotip). Логика вашего тестового кода может стать сложной для понимания, когда каждая запись в таблице имеет свою собственную условную логику для проверки каждого вывода для своих входных данных. Если у тестовых случаев различная логика, но идентичная настройка, имеет смысл использовать последовательность [подтестов](https://google.github.io/styleguide/go/decisions#subtests) внутри одной функции тестирования.

Вы можете комбинировать тесты на основе таблицы с несколькими функциями тестирования. Например, при тестировании того, что вывод функции точно соответствует ожидаемому выводу, и что функция возвращает ошибку не равную `nil` для недопустимого ввода, то лучшим подходом будет написание двух отдельных функций тестирования на основе таблицы: одна для нормального неошибочного вывода и одна для вывода ошибок.

#### Тестовы, основанные на данных

Строки таблицы тестов иногда могут стать сложными, когда значения строк определяют условное поведение внутри теста. Дополнительная ясность, обеспеченная дублированием между тестовыми случаями, необходима для удобочитаемости.
```
// Хорошо:
type decodeCase struct {
    name   string
    input  string
    output string
    err    error
}

func TestDecode(t *testing.T) {
    // setupCodex медленно создает реальный Codex для теста.
    codex := setupCodex(t)

    var tests []decodeCase //строки опущены для краткости

    for _, test := range tests {
        t.Run(test.name, func(t *testing.T) {
            output, err := Decode(test.input, codex)
            if got, want := output, test.output; got != want {
                t.Errorf("Decode(%q) = %v, ожидается: %v", test.input, got, want)
            }
            if got, want := err, test.err; !cmp.Equal(got, want) {
                t.Errorf("Decode(%q) err %q, ожидается: %q", test.input, got, want)
            }
        })
    }
}

func TestDecodeWithFake(t *testing.T) {
    // fakeCodex - это быстрая аппроксимация реального Codex.
    codex := newFakeCodex()

    var tests []decodeCase //строки опущены для краткости

    for _, test := range tests {
        t.Run(test.name, func(t *testing.T) {
            output, err := Decode(test.input, codex)
            if got, want := output, test.output; got != want {
                t.Errorf("Decode(%q) = %v, ожидается: %v", test.input, got, want)
            }
            if got, want := err, test.err; !cmp.Equal(got, want) {
                t.Errorf("Decode(%q) err %q, ожидается: %q", test.input, got, want)
            }
        })
    }
}
```
В приведенном ниже контрпримере обратите внимание, насколько сложно отличить, какой тип `Codex` используется для каждого тестового случая в настройке. (Части, выделенные цветом, нарушают рекомендации из [TotT: Ловушки, написанные данными!](https://testing.googleblog.com/2008/09/tott-data-driven-traps.html)).
```
// Плохо:
type decodeCase struct {
  name   string
  input  string
  codex  testCodex
  output string
  err    error
}

type testCodex int

const (
  fake testCodex = iota
  prod
)

func TestDecode(t *testing.T) {
  var tests []decodeCase //строки опущены для краткости

  for _, test := tests {
    t.Run(test.name, func(t *testing.T) {
      var codex Codex
      switch test.codex {
      case fake:
        codex = newFakeCodex()
      case prod:
        codex = setupCodex(t)
      default:
        t.Fatalf("неизвестный тип codex: %v", codex)
      }
      output, err := Decode(test.input, codex)
      if got, want := output, test.output; got != want {
        t.Errorf("Decode(%q) = %q, ожидается: %q", test.input, got, want)
      }
      if got, want := err, test.err; !cmp.Equal(got, want) {
        t.Errorf("Decode(%q) err %q, ожидается: %q", test.input, got, want)
      }
    })
  }
}
```

#### Определение строки

Не используйте индекс теста в таблице тестов в качестве замены именованию ваших тестов или выводу входных данных. Никто не хочет проходить через вашу таблицу тестов и считать записи, чтобы выяснить, в каком тестовом случае произошла ошибка.
```
// Плохо:
tests := []struct {
    input, want string
}{
    {"hello", "HELLO"},
    {"wORld", "WORLD"},
}
for i, d := range tests {
    if strings.ToUpper(d.input) != d.want {
        t.Errorf("неудачный тест #%d", i)
    }
}
```
Добавьте описание теста в структуру теста и печатайте его вместе с сообщениями об ошибках. При использовании подтестов имя подтеста должно быть эффективным при идентификации строки.

**Важно:** Несмотря на то, что `t.Run` ограничивает вывод и выполнение, вы должны всегда [указывать входные данные](https://google.github.io/styleguide/go/decisions#identify-the-input). Имена строк тестов должны соответствовать руководству по [именованию подтестов](https://google.github.io/styleguide/go/decisions#subtest-names).

### Помошники тестов

Помошник тестов - это функция, выполняющая задачу настройки или очистки. Ожидается, что все ошибки, которые возникают во время выполнения помошников тестов, будут ошибками среды (а не кода, который тестируется) - например, когда тестовая база данных не может быть запущена из-за отсутствия свободных портов на этой машине.

Если вы передаете `*testing.T`, вызовите [`t.Helper`](https://pkg.go.dev/testing#T.Helper), чтобы приписывать сбои вспомогательных функций теста строке, где была вызвана сама функция. Этот параметр должен идти после параметра [контекста](https://google.github.io/styleguide/go/decisions#contexts), если он присутствует, и перед любыми оставшимися параметрами.
```
// Хорошо:
func TestSomeFunction(t *testing.T) {
    golden := readFile(t, "testdata/golden-result.txt")
    // ... тестирование по golden ...
}

// readFile возвращает содержимое файла данных.
// Его следует вызывать только из той же горутины, которая запустила тест.
func readFile(t *testing.T, filename string) string {
    t.Helper()
    contents, err := runfiles.ReadFile(filename)
    if err != nil {
        t.Fatal(err)
    }
    return string(contents)
}
```
Не используйте этот шаблон, когда он затрудняет связь между ошибкой теста и условиями, приведшими к этому. В частности, рекомендации относительно [библиотек утверждений](https://google.github.io/styleguide/go/decisions#assert) по-прежнему актуальны, и [`t.Helper`](https://pkg.go.dev/testing#T.Helper) не должен использоваться для реализации таких библиотек.

**Совет:** Для получения дополнительной информации о различии между вспомогательными функциями теста и функциями утверждений смотри [лучшие практики](https://google.github.io/styleguide/go/best-practices#test-functions).

Хотя в приведенном выше примере упоминается `*testing.T`, множество советов остается таким же для помощников в бенчмарках и фаззинге.


### Тестовый пакет

#### Тесты в одном пакете

Тесты могут быть определены в том же пакете, что и тестируемый код.

Для написания теста в одном пакете:

* Поместите тесты в файл `foo_test.go`
* Используйте пакет `foo` для файла с тестом
* Не импортируйте явно пакет, который будет тестироваться

```
#Хорошо:
go_library(
    name = "foo",
    srcs = ["foo.go"],
    deps = [
        ...
    ],
)

go_test(
    name = "foo_test",
    size = "small",
    srcs = ["foo_test.go"],
    library = ":foo",
    deps = [
        ...
    ],
)
```
Тест в одном пакете может получить доступ к неэкспортированным идентификаторам в пакете. Это может позволить получить лучшую покрытие тестирования и более лаконичные тесты. Следует помнить, что любые [примеры](https://google.github.io/styleguide/go/decisions#examples), объявленные в тесте, не будут иметь имен пакетов, которые пользователь будет использовать в своем коде.

#### Тесты в другом пакете
Не всегда возможно или целесообразно определять тесты в том же пакете, что и код, который тестируется. В таких случаях используйте имя пакета с суффиксом `_test`. Это исключение из правила "без подчеркивания" для [имен пакетов](https://google.github.io/styleguide/go/decisions#package-names). Например:

* Если интеграционный тест не принадлежит явно определенной библиотеке
```
// Хорошо:
package gmailintegration_test

import "testing"
```
* Если определение тестов в том же пакете приводит к циклическим зависимостям
```
// Хорошо:
package fireworks_test

import (
  "fireworks"
  "fireworkstestutil" // fireworkstestutil также импортирует fireworks
)
```

### Используйте пакет `testing`

Стандартная библиотека Go предоставляет [`пакет testing`](https://pkg.go.dev/testing). Это единственный тестовый фреймворк, разрешенный для использования в коде на Go в кодовой базе Google. В частности, [библиотеки утверждений](https://google.github.io/styleguide/go/decisions#assert) и сторонние тестовые фреймворки не разрешены.

Пакет `testing` предоставляет минимальный, но полный набор функциональности для написания хороших тестов:

* Тесты верхнего уровня
* Бенчмарки
* [Примеры, которые можно запустить](https://blog.golang.org/examples)
* Подтесты
* Логирование
* Сбои и фатальные сбои
Они разработаны для совместной работы с основными возможностями языка, такими как [литералы композиции](https://go.dev/ref/spec#Composite_literals) и синтаксис [`if` с инициализатором](https://go.dev/ref/spec#If_statements), чтобы позволить авторам тестов писать [четкие, читаемые и поддерживаемые тесты].

## Вопросы без ответа

Руководство по стилю не может перечислить положительные рекомендации по всем вопросам, а также перечислить все вопросы, по которым оно не выражает своего мнения. Тем не менее, вот несколько вещей, в которых сообщество по повышению читаемости ранее вело дискуссии и не достигло однозначных соглашений.

* **Инициализация локальной переменной нулевым значением**. `var i int` и `i := 0` эквивалентны. См. также [лучшие практики инициализации](https://google.github.io/styleguide/go/best-practices#vardeclinitialization).
* **Пустой литерал составного типа vs `new` или `make`**. `&File{}` и `new(File)` эквивалентны. Также `map[string]bool{}` и `make(map[string]bool)` эквивалентны. См. также [лучшие практики для объявления составных типов](https://google.github.io/styleguide/go/best-practices#vardeclcomposite).
* **Порядок аргументов got, want в вызовах `cmp.Diff`**. Следуйте локальной согласованности и [включайте легенду](https://google.github.io/styleguide/go/decisions#print-diffs) в сообщение об ошибке.
* **`errors.New` vs `fmt.Errorf` на неотформатированных строках**. `errors.New("foo")` и `fmt.Errorf("foo")` могут быть использованы взаимозаменяемо.

Если есть особые обстоятельства, когда эти вопросы возникают снова, наставник по читаемости может оставить необязательный комментарий, но в целом автор вольны выбирать стиль, который предпочитают в данной ситуации.

Естественно, если вопрос, не рассмотренный в руководстве по стилю, требует дополнительного обсуждения, авторы могут обратиться за помощью - либо в конкретном обзоре, либо на внутренних форумах сообщества.
