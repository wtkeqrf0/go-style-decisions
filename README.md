# [Руководство по стилю](https://google.github.io/styleguide/)

# Стили Go кода

Ссылка на оригинальную статью: [https://google.github.io/styleguide/go/decisions](https://google.github.io/styleguide/go/decisions)

[Обзор](https://google.github.io/styleguide/go/index) | [Руководство](https://google.github.io/styleguide/go/guide) | [Решения](https://google.github.io/styleguide/go/decisions) | [Лучшие практики](https://google.github.io/styleguide/go/best-practices)

> Это часть серии документов, описывающих [стиль Go](https://google.github.io/styleguide/go/index) в Google. Этот документ является **[нормативным](https://google.github.io/styleguide/go/index#normative), но не [каноническим](https://google.github.io/styleguide/go/index#canonical)** и подчиняется основному [руководству по стилю](https://google.github.io/styleguide/go/guide). Пожалуйста, см. [обзор](https://google.github.io/styleguide/go/index#about) для получения дополнительной информации.

## О статье

Этот документ содержит решения о стиле, предназначенные для единообразия и стандартизации руководства, объяснений и примеров для консультаций, предоставляемых разработчиками читаемости в Go.

Документ не является **исчерпывающим** и будет развиваться со временем. В случаях, когда [основное руководство по стилю](https://google.github.io/styleguide/go/guide) противоречит рекомендациям, предоставленным здесь, **стилевой руководник имеет приоритет**, и этот документ должен быть обновлен в соответствии с этим.

Пожалуйста, см. [Обзор](https://google.github.io/styleguide/go#about) для полного набора документов о стиле Go.

Следующие разделы были перенесены из решений о стиле в другую часть руководства:

* **Форматирование**: см. [руководство#форматирование](https://google.github.io/styleguide/go/guide#formatting)
* **MixedCaps**: см. [руководство#midxed-caps](https://google.github.io/styleguide/go/guide#mixed-caps)
* **Длина линии**: см. [руководство#длина-линии](https://google.github.io/styleguide/go/guide#line-length)

## Названия
Итак, существует несколько правил по именованию в языке Go. Внимание к разделу о наименованиях в рамках [руководства по стилю](https://google.github.io/styleguide/go/guide#naming) для получения общей информации о выборе подходящих имен. Далее в разделах даются более подробные пояснения по конкретным областям, связанным с именованием.

### Подчеркивания
В целом, имена в Go не должны содержать подчеркивания. Однако есть три исключения к этому правилу:

1. Имена пакетов, которые импортируются только сгенерированным кодом, могут содержать подчеркивания. Для получения дополнительной информации об выборе имен пакетов из нескольких слов, можно обратиться к [разделу о именах пакетов](https://google.github.io/styleguide/go/decisions#package-names).
2. Имена функций Test, Benchmark и Example в файлах *_test.go могут содержать подчеркивания.
3. Низкоуровневые библиотеки, взаимодействующие с операционной системой или cgo, могут повторно использовать идентификаторы, как это делается в пакете [`syscall`](https://pkg.go.dev/syscall#pkg-constants). Однако в большинстве кодовых баз такое использование подчеркиваний будет очень редким.

### Названия пакетов

Мы ожидаем, что имена пакетов в Go будут короткими и содержать только строчные буквы. Имя пакета, состоящее из нескольких слов, должно быть написано в нижнем регистре без пробелов или подчёркиваний. Например, пакет с именем [`tabwriter`](https://pkg.go.dev/text/tabwriter) должен называться именно так, а не `tabWriter`, `TabWriter` или `tab_writer`.

Старайся избегать выбора таких имен пакетов, которые могут быть [вытеснены](https://google.github.io/styleguide/go/best-practices#shadowing) обычно используемыми именами локальных переменных. Например, `usercount` - более подходящее имя пакета, чем `count`, так как `count` является общеиспользуемым именем переменной.

Имена пакетов в Go не должны содержать подчёркивания. Если тебе нужно импортировать пакет, имя которого содержит подчёркивание (обычно это происходит из сгенерированного или стороннего кода), то это имя должно быть переименовано при импорте в имя, подходящее для использования в коде на Go.

Одно исключение из этого правила – имена пакетов, которые импортируются только сгенерированным кодом, могут содержать подчёркивания. Конкретные примеры использования подчёркивания включают:

* Использование суффикса _test для внешнего тестового пакета, например, для интеграционного тестирования.
* Использование суффикса _test для примеров [документации на уровне пакета](https://go.dev/blog/examples).

Не рекомендуется использовать неинформативные имена пакетов, такие как `util`, `utility`, `common`, `helper` и так далее. Более подробно об этом можно прочитать в статье ["utility packages"](https://google.github.io/styleguide/go/best-practices#util-packages) на блоге Go.

Когда импортируемый пакет переименовывается (например, `import foopb "path/to/foo_go_proto"`), локальное имя для пакета должно соответствовать вышеуказанным правилам, так как это локальное имя определяет, как ссылаться на символы в пакете внутри файла. Если один и тот же импорт пакета переименовывается в нескольких файлах, особенно в одном или близлежащих пакетах, следует использовать одно и то же локальное имя для достижения согласованности.

А вот ссылка на замечательную [статью в блоге Go о наименованиях пакетов](https://go.dev/blog/package-names).

### Названия получателей

Имена [переменных-получателей](https://golang.org/ref/spec#Method_declarations) должны быть:

* Короткими (обычно длиной в одну или две буквы)
* Сокращеними для самого типа
* Применяться последовательно к каждому приемнику этого типа

| Длинное название  | Лучше назвать |
| ------------- | ------------- |
| `func (tray Tray)`  | `func (t Tray)`  |
| `func (info *ResearchInfo)`  | `func (ri *ResearchInfo)`  |
| `func (this *ReportWriter)`  | `func (w *ReportWriter)`  |
| `func (self *Scanner)`  | `func (s *Scanner)`  |

### Имена констант

Имена констант должны использовать [MixedCaps](https://google.github.io/styleguide/go/guide#mixed-caps), как и все другие имена в Go. ([Экспортируемые](https://tour.golang.org/basics/3) константы начинаются с заглавной буквы, а неэкспортируемые константы начинаются с маленькой буквы.) Это относится даже тогда, когда это нарушает соглашения в других языках. Имена констант не должны быть производными от их значений, а должны объяснять, что это значение обозначает.

```
// Хорошо:
const MaxPacketSize = 512

const (
    ExecuteBit = 1 << iota
    WriteBit
    ReadBit
)
```
Старайтесь не использовать имена констант без MixedCaps и константы с префиксом `K`.
```
// Плохо:
const MAX_PACKET_SIZE = 512
const kMaxBufferSize = 1024
const KMaxUsersPergroup = 500
```
Давайте именовать константы на основе их роли, а не их значений. Если константа не имеет роли помимо своего значения, то нет необходимости определять ее как константу.
```
// Bad:
const Twelve = 12

const (
    UserNameColumn = "username"
    GroupColumn    = "group"
)
```

### Аббревиатуры

Слова в именах, которые являются инициалами или акронимами (например, `URL` и `NATO`), должны быть написаны с использованием одинакового регистра. `URL` должно появляться как `URL` или `url` (как в `urlPony` или `URLPony`), но никогда не как `Url`. То же самое относится к `ID`, когда это сокращение от "identifier"; используйте `appID` вместо `appId`.

* В именах с несколькими аббревиатурами (например, `XMLAPI`, поскольку она содержит `XML` и `API`), каждая буква в данной аббревиатуре должна быть в одинаковом регистре, но каждый инициал в имени не обязательно должен иметь одинаковый регистр.
* В именах с аббревиатурой, содержащей строчную букву (например, `DDoS`, `iOS`, `gRPC`), аббревиатура должна появляться так же, как в стандартном тексте, за исключением того случая, когда вам нужно изменить первую букву в целях [экспортирования](https://golang.org/ref/spec#Exported_identifiers). В таких случаях вся аббревиатура должна иметь одинаковый регистр (например, `ddos`, `IOS`, `GRPC`).

| Аббревиатура | Доступность | Правильно | Неправильно |
| ------------- | ------------- | ------------- | ------------- |
| XML API | Exported | `XMLAPI` | `XmlApi`, `XMLApi`, `XmlAPI`, `XMLapi` |
| XML API | Unexported | `xmlAPI` | `xmlapi`, `xmlApi` |
| iOS | Exported | `IOS` | `Ios`, `IoS` |
| iOS | Unexported | `iOS` | `ios` |
| gRPC | Exported | `GRPC` | `Grpc` |
| gRPC | Unexported | `gRPC` | `grpc` |
| DDoS | Exported | `DDoS` | `DDOS`, `Ddos` |
| DDoS | Unexported | `ddos` | `dDoS`, `dDOS` |

### Геттеры

Названия функций и методов не должны использовать префикс `Get` или `get`, если базовая концепция не использует слово "get" (например, HTTP GET). Предпочтительнее начинать название прямо с существительного, например, использовать `Counts` вместо `GetCounts`.

Если функция включает выполнение сложных вычислений или вызов удаленного сервера, можно использовать другое слово, например `Compute` (вычисление) или `Fetch` (получение), чтобы ясно указать читателю, что вызов функции может занять время, блокироваться или завершиться неудачей.

### Названия переменных

Общее правило состоит в том, что длина имени должна быть пропорциональна размеру его области видимости и обратно пропорциональна количеству его использования в этой области. Переменная, созданная в глобальной области видимости файла, может требовать нескольких слов, тогда как переменная, ограниченная одним внутренним блоком, может быть как одним словом, так и несколькими символами, для того, чтобы код был чистым и не содержал лишней информации.

Вот грубый ориентир. Эти числовые рекомендации не являются строгими правилами. Применяйте суждение, основанное на контексте, [ясности](https://google.github.io/styleguide/go/guide#clarity) и [краткости](https://google.github.io/styleguide/go/guide#concision).

* Маленькая область - это область, в которой выполняется одна или две небольшие операции, скажем, 1-7 строк.
* Средняя область - это несколько небольших или одна большая операция, скажем, 8-15 строк.
* Большая область - это одна или несколько больших операций, скажем, от 15 до 25 строк.
* Очень большая область - это все, что простирается на несколько страниц (скажем, более 25 строк).

Имя, которое может быть полностью понятным (например, `c` для счетчика) внутри маленькой области, может оказаться недостаточным в большой области и потребовать пояснения, чтобы напомнить читателю его назначение в более поздних частях кода. Область, в которой существует много переменных или переменных, представляющих сходные значения или концепции, может потребовать более длинных имен переменных, чем область предполагает.

Специфичность концепции также может помочь в сохранении краткости имени переменной. Например, если предполагается, что используется только одна база данных, короткое имя переменной, такое как `db`, которое обычно зарезервировано для очень маленьких областей, может оставаться полностью понятным даже при очень большой области. В этом случае, единственное слово `database`, вероятно, будет приемлемо, основываясь на размере области, но не обязательно, поскольку `db` является очень распространенным сокращением для этого слова с немногими альтернативными интерпретациями.

Имя локальной переменной должно отражать то, что она содержит и как она используется в текущем контексте, а не откуда получено значение. Например, часто бывает так, что лучшее имя локальной переменной не совпадает с именем поля в структуре или протокольном буфере.

Резюмируя:

* Однословные имена, такие как `count` или `options`, являются хорошим началом.
* Дополнительные слова можно добавить для устранения неоднозначности схожих имен, например `userCount` и `projectCount`.
* Не сокращайте буквы просто, чтобы сэкономить время. Например, предпочтительнее использовать `Sandbox` вместо `Sbx`, особенно для экспортируемых имен.
* Оставляйте [типы и типо-подобные слова](https://google.github.io/styleguide/go/decisions#repetitive-with-type) в большинстве имен переменных.
  * Для чисел имя `userCount` лучше, чем `numUsers` или `usersInt`.
  * Для среза, имя `users` лучше, чем `userSlice`.
  * При необходимости можно добавить квалификатор типа, если в области видимости есть две версии значения, например, можно хранить входные данные в `ageString`, а использовать `age` для преобразованного значения.
* Пропускайте слова, ясные из [окружающего контекста](https://google.github.io/styleguide/go/decisions#repetitive-in-context). Например, при реализации метода `UserCount`, локальная переменная с именем `userCount`, вероятно, будет избыточной; `count`, `users` или даже `c` так же читаемы.

#### Однобуквенные названия переменных

Однобуквенные идентификаторы переменных могут быть полезными для минимизации [повторений](https://google.github.io/styleguide/go/decisions#repetition), но они также могут делать код более непонятным. Ограничьте их использование случаями, когда полное слово очевидно и когда его повторное использование было бы излишним.

Резюмируя:

* Для [переменной-получателя метода](https://google.github.io/styleguide/go/decisions#receiver-names) предпочтительно использовать однобуквенное или двухбуквенное имя.
* Использование знакомых идентификаторов переменных для общих типов часто полезно:
  * `r` для `io.Reader` или `*http.Request`
  * `w` для `io.Writer` или `http.ResponseWriter`
* Однобуквенные идентификаторы допустимы как целочисленные переменные для циклов, особенно для индексов (например, `i`) и координат (например, `x` и `y`).
* Аббревиатуры могут быть допустимыми идентификаторами циклов, когда область короткая, например, `for _, n := range nodes { ... }`.

### Повторение
Исходный код на Go должен избегать ненужного повторения. Одним из распространенных источников этого являются повторяющиеся имена, которые часто содержат лишние слова или повторяют свой контекст или тип. Сам код также может быть излишне повторяющимся, если один и тот же или похожий код появляется несколько раз в непосредственной близости.

Повторяющиеся имена могут принимать различные формы, включая:

#### Название пакета против названия экспортированного символа
При именовании экспортированных символов имя пакета всегда видимо за пределами вашего пакета, поэтому избыточную информацию между ними следует уменьшать или устранять. Если пакет экспортирует только один тип, и он назван в честь самого пакета, каноническое имя для конструктора - `New`, если он требуется.

> Примеры: Повторяющееся имя -> Лучшее имя
> 
> * widget.NewWidget -> widget.New
> * widget.NewWidgetWithName -> widget.NewWithName
> * db.LoadFromDatabase -> db.Load
> * goatteleportutil.CountGoatsTeleported -> gtutil.CountGoatsTeleported или goatteleport.Count
> * myteampb.MyTeamMethodRequest -> mtpb.MyTeamMethodRequest или myteampb.MethodRequest

#### Название переменной против типа

Компилятор всегда знает тип переменной, и в большинстве случаев для читателя также ясно, какой тип переменной по тому, как она используется. Необходимо уточнить тип переменной только в случае, если ее значение появляется дважды в одной и той же области видимости.

| Повторяющееся имя | Лучшее имя |
| ------------- | ------------- |
| `var numUsers int` |  `var users int` |
| `var nameString string` | `var name string` |
| `var primaryProject Project` | `var primary Project` |

Если значение появляется в нескольких формах, это можно пояснить либо с помощью дополнительного слова, например `raw` и `parsed`, либо с помощью базового представления:
```
// Хорошо:
limitStr := r.FormValue("limit")
limit, err := strconv.Atoi(limitStr)
```
```
// Хорошо:
limitRaw := r.FormValue("limit")
limit, err := strconv.Atoi(limitRaw)
```

#### Внешний контекст против локальных названий
Имена, которые включают информацию из окружающего контекста, часто создают дополнительный шум без пользы. Имя пакета, имя метода, имя типа, имя функции, путь импорта и даже имя файла могут предоставлять контекст, который автоматически квалифицирует все имена внутри.
```
// Плохо:
// В пакете "ads/targeting/revenue/reporting"
type AdsTargetingRevenueReport struct{}

func (p *Project) ProjectName() string
```
```
// Хорошо:
// В пакете "ads/targeting/revenue/reporting"
type Report struct{}

func (p *Project) Name() string
```
```
// Плохо:
// В пакете "sqldb"
type DBConnection struct{}
// Хорошо:
// В пакете "sqldb"
type Connection struct{}
```
```
// Плохо:
// В пакете "ads/targeting"
func Process(in pb.FooProto) Report {
    adsTargetingID := in.GetAdsTargetingID()
}
```
```
// Хорошо:
// В пакете "ads/targeting"
func Process(in pb.FooProto) Report {
    id := in.GetAdsTargetingID()
}
```
Повторение следует оценивать в контексте пользователей символа, а не в изоляции. Например, в следующем коде много имен, которые могут быть приемлемыми в некоторых случаях, но излишние в конкретном контексте:
```
// Плохо:
func (db *DB) UserCount() (userCount int, err error) {
    var userCountInt64 int64
    if dbLoadError := db.LoadFromDatabase("count(distinct users)", &userCountInt64); dbLoadError != nil {
        return 0, fmt.Errorf("failed to load user count: %s", dbLoadError)
    }
    userCount = int(userCountInt64)
    return userCount, nil
}
```
Вместо этого информацию о именах, которые явны из контекста или использования, можно часто опускать:
```
// Хорошо:
func (db *DB) UserCount() (int, error) {
    var count int64
    if err := db.Load("count(distinct users)", &count); err != nil {
        return 0, fmt.Errorf("failed to load user count: %s", err)
    }
    return int(count), nil
}
```

## Комментарии
Соглашения относительно комментирования (какие части кода комментировать, какой стиль использовать, как предоставлять запускаемые примеры и т. д.) предназначены для поддержки опыта чтения документации общедоступного API. Смотрите [Effective Go](http://golang.org/doc/effective_go.html#commentary) для получения дополнительной информации.

Лучшие практики документирования обсуждаются более подробно в главе [Правила документирования](https://google.github.io/styleguide/go/best-practices#documentation-conventions)

**Лучшая практика:** используйте [предварительный просмотр документации](https://google.github.io/styleguide/go/best-practices#documentation-preview) во время разработки и обзора кода, чтобы увидеть, полезны ли документация и запускаемые примеры, и представлены ли они так, как вы ожидаете.

**Совет:** Godoc использует очень незначительное форматирование; списки и фрагменты кода обычно следует делать с отступом, чтобы избежать переноса строк. За исключением отступов, обычно следует избегать оформления.

### Длина строки комментария
Обеспечьте возможность чтения комментариев из исходного кода даже на узких экранах.

Когда комментарий становится слишком длинным, рекомендуется разделить его на несколько однострочных комментариев. Старайтесь, по возможности, делать комментарии так, чтобы они хорошо читались на терминале шириной 80 символов, но это не жесткий предел; в Go нет фиксированного ограничения на длину строк комментариев. Например, стандартная библиотека часто разбивает комментарии на отдельные строки в зависимости от знаков препинания, что иногда приводит к длине строк около 60-70 символов.

Существует много существующего кода, в котором комментарии превышают 80 символов в длину. Однако этот факт не должен служить оправданием для изменения такого кода при анализе читаемости (см. [согласованность](https://google.github.io/styleguide/go/guide#consistency), хотя командам рекомендуется при возможности обновлять комментарии в соответствии с этим руководством в рамках других рефакторингов. Основная цель этого руководства - обеспечить, чтобы все руководители читабельности кода на Go давали одни и те же рекомендации при необходимости.

Пример хорошего комментария, который демонстрирует правильное форматирование:
```
// Это параграф комментария.
// Длина отдельных строк не имеет значения в Godoc;
// но выбор разделения делает его легко читаемым на узких экранах.
//
// Не беспокойтесь слишком сильно о длинном URL:
// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/
//
// Аналогично, если у вас есть другая информация, которая становится неудобной
// из-за слишком многих переносов строк, используйте свой суд и включите длинную строку,
// если это помогает, а не мешает.
```
Пример плохого комментария, который не следует рекомендациям форматирования:
```
// Это параграф комментария. Длина отдельных строк не имеет значения в
Godoc;
// но выбор разделения вызывает неровные строки на узких экранах или в рецензии
кода,
// что может быть раздражающим, особенно когда комментарий переносится
постоянно.
//
// Не беспокойтесь слишком сильно о длинном URL:
// https://supercalifragilisticexpialidocious.example.com:8080/Animalia/Chordata/Mammalia/Rodentia/Geomyoidea/Geomyidae/
```

Важно следовать этим рекомендациям, чтобы сделать ваш код более читабельным и согласованным. Если вам интересно узнать больше о комментировании, рекомендуется прочитать [публикацию в блоге Go о документации](https://blog.golang.org/godoc-documenting-go-code).

### Комментарии к документации

Все имена верхнего уровня, экспортируемые из пакета, должны иметь документационные комментарии, также как и объявления неэкспортируемых типов или функций, имеющих неочевидное поведение или значение. Эти комментарии должны быть [полными предложениями](https://google.github.io/styleguide/go/decisions#comment-sentences), начинающимися с названия описываемого объекта. Можно использовать артикль ("a", "an", "the") перед названием для более естественного чтения.
```
// Хорошо:
// Request представляет запрос для выполнения команды.
type Request struct { ...

// Encode записывает JSON-кодировку req в w.
func Encode(w io.Writer, req *Request) { ...
```
Документационные комментарии отображаются в [Godoc](https://pkg.go.dev/) и доступны в интегрированных средах разработки, и поэтому они должны быть написаны для всех, кто использует пакет.

Документационный комментарий применяется к следующему символу или группе полей в случае структуры.
```
// Хорошо:
// Options настраивает службу управления группой.
type Options struct {
    // Общая настройка:
    Name  string
    Group *FooGroup

    // Зависимости:
    DB *sql.DB

    // Пользовательские настройки:
    LargeGroupThreshold int // опциональный, по умолчанию: 10
    MinimumMembers      int // опциональный, по умолчанию: 2
}
```
**Лучшая практика:** Если у вас есть документационные комментарии для неэкспортируемого кода, следуйте тому же шаблону, как если бы он был экспортируемым (в частности, начинайте комментарий с неэкспортируемого имени). Это позволит легко экспортировать его позднее, просто заменив неэкспортируемое имя на новое экспортируемое в комментариях и коде.

### Предложения в комментариях

Комментарии, которые представляют собой полные предложения, должны быть написаны с заглавной буквы и знаком препинания, как в обычном английском предложении. (Исключение составляют случаи, когда предложение начинается с идентификатора, написанного с маленькой буквы, если его значение явно и понятно. Такие случаи, вероятно, лучше употреблять только в начале абзацев.)

Комментарии, которые являются фрагментами предложений, не требуют пунктуации или написания с заглавной буквы.

[Комментарии к документации](https://google.github.io/styleguide/go/decisions#doc-comments) должны всегда представлять собой полные предложения и, следовательно, должны начинаться с заглавной буквы и иметь знаки препинания. Простые комментарии в конце строки (особенно для полей в структурах) могут быть простыми фразами, начиная с предположения, что имя поля является подлежащим.

```
// Good:
// A Server handles serving quotes from the collected works of Shakespeare.
type Server struct {
    // BaseDir points to the base directory under which Shakespeare's works are stored.
    //
    // The directory structure is expected to be the following:
    //   {BaseDir}/manifest.json
    //   {BaseDir}/{name}/{name}-part{number}.txt
    BaseDir string

    WelcomeMessage  string // отображается при входе пользователя
    ProtocolVersion string // проверяется при входящих запросах
    PageLength      int    // количество строк на странице при печати (опционально, по умолчанию: 20)
}
```

### Примеры

Пакеты должны четко документировать предполагаемое использование. Старайтесь предоставить [запускаемый пример](http://blog.golang.org/examples); примеры отображаются в Godoc. Запускаемые примеры должны находиться в тестовом файле, а не в файле исходного кода продукции. Смотрите этот пример ([Godoc](https://pkg.go.dev/time#example-Duration), [исходный код](https://cs.opensource.google/go/go/+/HEAD:src/time/example_test.go)).

Если невозможно предоставить запускаемый пример, код примера можно указать в комментариях к коду. Как и другие фрагменты кода и командной строки в комментариях, он должен соответствовать стандартным соглашениям форматирования.

### Именованные параметры результата

При именовании параметров результата следует учитывать, как функции отображаются в Godoc. Само имя функции и тип параметров результата часто достаточно понятны.
```
// Хорошо:
func (n Node) Parent1() Node
func (n Node) Parent2() (Node, error)
```
Если функция возвращает два или более параметра одного типа, их именование может быть полезным.
```
// Хорошо:
func (n Node) Children() (left, right Node, err error)
```
Если вызывающая сторона должна предпринять действия в отношении конкретных параметров результата, их именование может помочь указать, какие действия требуются:
```
// Хорошо:
// WithTimeout возвращает контекст, который будет отменен не позднее, чем через
// заданное время d от текущего момента.
//
// Вызывающая сторона должна убедиться, что возвращенная функция cancel будет
// вызвана, когда контекст больше не нужен, чтобы избежать утечки ресурсов.
func WithTimeout(parent Context, d time.Duration) (ctx Context, cancel func())
```
В приведенном выше коде отмена - это конкретное действие, которое должна предпринять вызывающая сторона. Однако, если бы параметры результата были записаны просто как `(Context, func())`, было бы неясно, что имеется в виду под "функцией отмены".

Не используйте именованные параметры результата, когда имена вызывают [лишнее повторение](https://google.github.io/styleguide/go/decisions#repetitive-with-type).
```
// Плохо:
func (n Node) Parent1() (node Node)
func (n Node) Parent2() (node Node, err error)
```
Не именуйте параметры результата, чтобы избежать объявления переменных внутри функции. Эта практика приводит к ненужной избыточности API за счет незначительного укорочения кода.

[Именованные возвращаемые значения](https://tour.golang.org/basics/7) допустимы только в небольших функциях. Как только функция становится среднего размера, следует явно указывать возвращаемые значения. Аналогично, не именуйте параметры результата просто потому, что это позволяет использовать именованные возвращаемые значения. [Ясность](https://google.github.io/styleguide/go/guide#clarity) всегда важнее, чем экономия нескольких строк в функции.

Всегда допустимо именовать параметр результата, если его значение должно быть изменено в отложенном (deferred) замыкании.

> **Совет:** Типы часто могут быть более понятными, чем имена в сигнатуре функции. [GoTip #38: "Функции как именованные типы"](https://google.github.io/styleguide/go/index.html#gotip) демонстрирует это.
> 
> Опираясь на пример выше с [`WithTimeout`](https://pkg.go.dev/context#WithTimeout), настоящий код использует [`CancelFunc`](https://pkg.go.dev/context#CancelFunc) вместо простого `func()` в списке параметров результата и не требует больших усилий для документирования.

### Комментарии к пакету

Комментарии к пакету должны быть непосредственно над предложением пакета без пустой строки между комментарием и именем пакета. Пример:
```
// Хорошо:
// Пакет math предоставляет основные константы и математические функции.
//
// Этот пакет не гарантирует одинаковые результаты между архитектурами.
package math
```
В пакете должен быть один комментарий к пакету на каждый пакет. Если пакет состоит из нескольких файлов, ровно один из файлов должен содержать комментарий к пакету.

Комментарии для пакетов `main` имеют немного другую форму, где имя правила `go_binary` в файле BUILD заменяет имя пакета.
```
// Хорошо:
// Команда seed_generator - это утилита, которая генерирует файл симуляции Finch
// из набора JSON-конфигураций исследования.
package main
```
Другие стили комментариев допустимы, если имя двоичного файла соответствует имени, указанному в файле BUILD. Когда имя двоичного файла является первым словом, его следует писать с заглавной буквы, даже если оно не соответствует строго написанию командной строки.
```
// Хорошо:
// Двоичный файл seed_generator ...
// Команда seed_generator ...
// Программа seed_generator ...
// Команда seed_generator ...
// Программа seed_generator ...
// Seed_generator ...
```
Советы:

* Примеры командной строки и использования API могут быть полезной документацией. Для форматирования в Godoc следует добавить отступы перед строками комментария, содержащими код.
* Если нет очевидного основного файла или если комментарий к пакету является чрезвычайно длинным, можно поместить комментарий в файл с именем `doc.go`, содержащим только комментарий и предложение пакета.
* Многострочные комментарии можно использовать вместо нескольких однострочных комментариев. Это особенно полезно, если документация содержит разделы, которые можно скопировать и вставить из исходного файла, например, с примерами командной строки (для двоичных файлов) и примерами шаблонов.
```
// Хорошо:
/*
Команда seed_generator - это утилита, которая генерирует файл симуляции Finch
из набора JSON-конфигураций исследования.

    seed_generator *.json | base64 > finch-seed.base64
*/
package template
```
* Комментарии, предназначенные для сопровождающих и применимые к всему файлу, обычно размещаются после импорта. Они не отображаются в Godoc и не подчиняются правилам, указанным выше для комментариев к пакету.

## Импорты

### Переименование инпортов

Импорты должны переименовываться только для избежания конфликта имён с другими импортами. (Как следствие этого, [хорошие имена пакетов](https://google.github.io/styleguide/go/decisions#package-names) не должны требовать переименования.) В случае конфликта имён предпочтительно переименовывать наиболее локальный или специфичный для проекта импорт. Локальные имена (псевдонимы) для пакетов должны следовать [рекомендациям по именованию пакетов](https://google.github.io/styleguide/go/decisions#package-names), включая запрет на использование подчеркиваний и заглавных букв.

Сгенерированные пакеты протоколов (protocol buffer packages) должны быть переименованы для удаления подчеркиваний из их имен, и их псевдонимы должны иметь суффикс `pb`. См. [рекомендации по протоколам и транспортам](https://google.github.io/styleguide/go/best-practices#import-protos) для получения дополнительной информации.
```
// Хорошо:
import (
    fspb "path/to/package/foo_service_go_proto"
)
```
Импорты, у которых имена пакетов не содержат полезной идентификационной информации (например, `package v1`), должны быть переименованы, чтобы включать предыдущий компонент пути. Переименование должно быть согласовано с другими локальными файлами, импортирующими тот же пакет, и может включать номер версии.

**Примечание:** Желательно переименовывать пакеты так, чтобы они соответствовали [хорошим именам пакетов](https://google.github.io/styleguide/go/decisions#package-names), но это часто неосуществимо для пакетов в каталогах продавцов.
```
// Хорошо:
import (
    core "github.com/kubernetes/api/core/v1"
    meta "github.com/kubernetes/apimachinery/pkg/apis/meta/v1beta1"
)
```

Если вам нужно импортировать пакет, имя которого совпадает с общим именем локальной переменной, которую вы хотите использовать (например, `url`, `ssh`) и вы хотите переименовать пакет, предпочтительный способ сделать это - это добавить суффикс `pkg` (например, `urlpkg`). Обратите внимание, что пакет можно замаскировать локальной переменной; переименование необходимо только в случае, если пакет все еще должен использоваться, когда такая переменная находится в области видимости.

### Группировка импортов
Импорты должны быть организованы в две группы:
* Пакеты стандартной библиотеки
* Другие (проектные и пакеты от поставщиков)
```
// Хорошо:
package main

import (
    "fmt"
    "hash/adler32"
    "os"

    "github.com/dsnet/compress/flate"
    "golang.org/x/text/encoding"
    "google.golang.org/protobuf/proto"
    foopb "myproj/foo/proto/proto"
    _ "myproj/rpc/protocols/dial"
    _ "myproj/security/auth/authhooks"
)
```

Допускается разделение проектных пакетов на несколько групп, например, если вы хотите отдельную группу для переименованных, импортированных только для побочных эффектов или еще какую-то особую группу импортов.
```
// Хорошо:
package main

import (
    "fmt"
    "hash/adler32"
    "os"

    "github.com/dsnet/compress/flate"
    "golang.org/x/text/encoding"
    "google.golang.org/protobuf/proto"

    foopb "myproj/foo/proto/proto"

    _ "myproj/rpc/protocols/dial"
    _ "myproj/security/auth/authhooks"
)
```

**Примечание:** Поддержка необязательных подгрупп, таких как стандартная библиотека и импорты Google - не поддерживается инструментом [goimports](https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports). Дополнительные подгруппы импортов требуют внимания со стороны авторов и рецензентов для поддержания соответствующего состояния.

Программы Google, которые также являются приложениями AppEngine, должны иметь отдельную группу для импортов AppEngine.

Gofmt заботится о сортировке каждой группы по пути импорта. Однако он не разделяет импорты автоматически на группы. Популярный инструмент [goimports](https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports) объединяет Gofmt и управление импортами, разделяя импорты на группы на основе принятого решения. Допускается полностью доверить [goimports](https://google.github.io/styleguide/go/golang.org/x/tools/cmd/goimports) управление порядком импортов, так что даже при изменении файла, его список импортов будет оставаться внутренне согласованным.

### Импорт "пустого" пакета (`import _`)

Пакеты, которые импортируются только для своих побочных эффектов (используя синтаксис `import _ "package"`), могут быть импортированы только в главный пакет или в тесты, которым они нужны.

Некоторые примеры таких пакетов включают:
* [time/tzdata](https://pkg.go.dev/time/tzdata)
* [image/jpeg](https://pkg.go.dev/image/jpeg) в коде обработки изображений

Избегайте пустых импортов в библиотечных пакетах, даже если библиотека зависит от них косвенно. Ограничение импортов с побочными эффектами до главного пакета помогает контролировать зависимости и позволяет писать тесты, основанные на другом импорте, без конфликтов или излишних затрат на сборку.

Следующий список является единственным исключением из этого правила:
* Вы можете использовать пустой импорт для обхода проверки на запрещенные импорты в [статическом анализаторе nogo](https://github.com/bazelbuild/rules_go/blob/master/go/nogo.rst).
* Вы можете использовать пустой импорт пакета [embed](https://pkg.go.dev/embed) в исходном файле, который использует компиляторную директиву `//go:embed`.

**Совет:** Если вы создаете библиотечный пакет, который косвенно зависит от импорта с побочными эффектами в продакшене, задокументируйте предполагаемое использование.

### Импорт "точка" (`import .`)

Форма `import .` - это возможность языка, позволяющая привносить идентификаторы, экспортируемые из другого пакета, в текущий пакет без квалификации. Дополнительную информацию см. в [спецификации языка](https://go.dev/ref/spec#Import_declarations).

**Не** используйте эту функцию в кодовой базе Google; это затрудняет определение, откуда идет функциональность.
```
// Плохо:
package foo_test

import (
    "bar/testutil" // также импортирует "foo"
    . "foo"
)

var myThing = Bar() // Bar определен в пакете foo; не требуется квалификация.
```
```
// Хорошо:
package foo_test

import (
    "bar/testutil" // также импортирует "foo"
    "foo"
)

var myThing = foo.Bar()
